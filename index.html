<!DOCTYPE html>
<html lang="zh-CN">

  
<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="author" content="tldr">
  <meta name="generator" content="Hugo 0.18.1" />
  <title>TL;DR BLOG</title>

  <meta name="description" content="">
  <link rel="canonical" href="https://zyx-vec.github.io/myblog/">
  <link href="https://zyx-vec.github.io/myblog/index.xml" rel="alternate" type="application/rss+xml" title="TL;DR BLOG">
  <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Source+Code+Pro|Arvo:400,700">
  <link rel="stylesheet" href="https://zyx-vec.github.io/myblog/css/highlight.css">
  <link rel="stylesheet" href="https://zyx-vec.github.io/myblog/css/paperback.css">
</head>


  <body>
    <div class="container">

      <header>
  <h1>TL;DR BLOG</h1>

  

  
</header>


      <section>

        
        <article>
          <h2><a href="https://zyx-vec.github.io/myblog/post/inline_asm_in_gcc/">在 C 中内嵌汇编代码</a></h2>
<div>
  
    C/C++ 代码中嵌入汇编
如果阅读过Linux源码，就可以发现其中的C中嵌入汇编指令；众所周知汇编生产力极低，但是汇编指令写出的程序的性能却是极高的，可以能够榨干CPU的计算能力。本文通过例子的方式给出在GCC中的C/C++（两个语言规则一样，下文直接用C来描述）代码中嵌入汇编代码块的一些基本规则。
基本模板
__asm__(&quot;inst0\n\t&quot;	/* basic instructions */ &quot;inst1\n\t&quot; :&quot;=?&quot;(),&quot;=?&quot;()...	/* outputs */ :&quot;?&quot;(),&quot;?&quot;()...	/* inputs */ :&quot;?&quot;...);	/* clobbered registers */ // 其中__asm__和asm是等价的，可以相互替换。  上面就是C源程序中嵌入汇编指令的基本模板。可见模板由5部分组成：
 基本框架 __asm__(); 在括号中填入汇编指令和其他上下文信息。 汇编指令部分，位于括号的前面部分，上述模板中inst0 inst1..就是汇编指令的代指。 由于嵌入的汇编代码块有一个上下文的环境，所以就需要接下来的三个:起始的限制（constraints）信息。  第一个 : 用于指定输出的变量由哪个寄存器来持有输出结果，&quot;&quot; 用于指定寄存器，() 中写变量名。 第二个 : 用于指定输入的变量由哪个寄存器来持有输入内容，&quot;&quot; 用于指定寄存器，() 中写变量名。 第三个 : 用于告诉编译器这个代码块中哪些内容是会被修改的，比如 :&quot;%eax&quot; 表示代码块中会修改寄存器%eax的值。   由于三个 : 不是必需的，有时能够看到例如 :::&quot;m&quot; 的内容，这就表示输出和输入都没有，但是这个代码块会修改内存中的内容（&quot;m&quot;表示内存）。
简单示例
#include &lt;stdio.h&gt; int main(int argc, char** argv) { int a = 10, b; __asm__(&quot;movl %1, %%eax\n\t&quot; &quot;movl %%eax, %0\n\t&quot; :&quot;=r&quot;(b)	/* output */ :&quot;r&quot; (a)	/* input */ :&quot;%eax&quot;	/* clobbered register */ ); printf(&quot;Result %d\n&quot;, b); return 0; }  上述 __asm__() 中代码的作用是将变量a中的值拷贝到变量b中。

    <footer>
      <a href="https://zyx-vec.github.io/myblog/post/inline_asm_in_gcc/">Read more</a>
    </footer>
  
</div>

        </article>
        
        <article>
          <h2><a href="https://zyx-vec.github.io/myblog/post/CPP_Object_Model/">探讨C&#43;&#43; 对象模型</a></h2>
<div>
  
    C++ 起源于 C，兼具底层和高级抽象的能力，能够进行底层操作，往往也称为“面向内存”编程；和 Java、Python 等语言不一样，C++ 中的“对象”的内存布局是透明的，可以被利用的（大雾，切勿依靠没有写入标准的一般经验），也即“面向内存”编程，而在 Java 中创建一个自己编写类的对象，但是对象实例中包含很多的“控制”和“辅助”信息，比如对象头等，内存效率比C++低，性能也更低。
除开 C++ 中的基本类型，掌握 C++ 中的对象模型，对于理解一些C++中的常见套路是很有帮助的，例如 C++ 中的 rule of three，运行时多态等等。
而对象模型中最重要的就是 virtual 机制，C++ 就是通过其实现运行时多态（runtime polymorphism）。“多态”按字面意思即多种表现形态，C++中就是利用相同的接口表现出不同的运行结果，故有编译时多态（compile time polymorphism）- 重载、模板 和 运行时多态（runtime compile polymorphism）。我们都知道 C++ 有强大的模板，而模板的开销主要在编译时，对应的运行时多态的开销主要体现在对象模型上，其中最重要的就是虚函数指针和虚函数表的存在，本文的目的就是探讨C++中的对象模型中的 virtual 机制。
虚函数的作用
虚函数的作用就是运行时多态，先看如下代码
class Animal { virtual void bark() = 0; }; class Dog : public Animal { void bark() { cout &lt;&lt; &quot;WangWang~\n&quot;; } }; class Cat : public Animal { void bark() { cout &lt;&lt; &quot;Meow~\n&quot;; } }; Animal *pet1 = new Dog(); Animal *pet2 = new Cat(); pet1-&gt;bark();	// WangWang~ pet2-&gt;bark();	// Meow~  由此可见，利用同样的运行时类型 Animal*，使用同样的接口（Interface），最终表现出不一样的行为状态。这就是运行时多态的目标，具体参考《C++程序设计与演化》（C++ D&amp;E）来探讨该技术的来源，和其中所经历的过程。

    <footer>
      <a href="https://zyx-vec.github.io/myblog/post/CPP_Object_Model/">Read more</a>
    </footer>
  
</div>

        </article>
        
        <article>
          <h2><a href="https://zyx-vec.github.io/myblog/post/leveldb/">开源项目 leveldb 的编译测试</a></h2>
<div>
  
    step 0 : git clone leveldb source code.
step 1 : cd leveldb
step 2 : make
下一步将 include 头文件拷贝到 /usr/include/目录中。
step 3 : sudo cp -r ./include/leveldb /usr/include
​ db.h 可能不在 leveldb 目录中，找到他并拷贝到 /usr/include 中即可。
以下步骤将生成的动态链接库拷贝到 /usr/lib 目录中，创建两个软连接，最终得到 libleveldb.so
step 4 : sudo cp ./out-shared/libleveldb.so.1.18 /usr/lib
step 5 : cd /usr/lib
step 6 : sudo ln -s libleveldb.so.1.18 libleveldb.so.1
step 7 : sudo ln -s libleveldb.so.1 libleveldb.so
step 8 : sudo ldconfig

    <footer>
      <a href="https://zyx-vec.github.io/myblog/post/leveldb/">Read more</a>
    </footer>
  
</div>

        </article>
        

      </section>

      <nav class="site-nav">
  <a href="https://zyx-vec.github.io/myblog/">Home</a>
  <a href="https://zyx-vec.github.io/myblog/post/">All posts</a>

  

    

</nav>


      <footer class="site-footer">
  <span class="owner">©2016 tldr</span>

  
</footer>


    </div>

  
<script src="https://zyx-vec.github.io/myblog/js/highlight.pack.js"></script>
<script>hljs.initHighlightingOnLoad();</script>

  </body>
</html>
