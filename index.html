<!DOCTYPE html>
<html lang="zh-CN">

  
<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="author" content="">
  <meta name="generator" content="Hugo 0.17" />
  <title>TL;DR BLOG</title>

  <meta name="description" content="">
  <link rel="canonical" href="https://zyx-vec.github.io/myblog/">
  <link href="https://zyx-vec.github.io/myblog/index.xml" rel="alternate" type="application/rss+xml" title="TL;DR BLOG">
  <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Source+Code+Pro|Arvo:400,700">
  <link rel="stylesheet" href="https://zyx-vec.github.io/myblog/css/highlight.css">
  <link rel="stylesheet" href="https://zyx-vec.github.io/myblog/css/paperback.css">
</head>


  <body>
    <div class="container">

      <header>
  <h1>TL;DR BLOG</h1>

  

  
</header>


      <section>

        
        <article>
          <h2><a href="https://zyx-vec.github.io/myblog/post/is_constructible/">is_convertible&lt;U, T&gt; 和 is_constructible&lt;T, U&gt;</a></h2>
<div>
  
    is_convertible和 is_constructible是否等价
C++ 11 中引入了强大的 type_traits，顾名思义，它增强了 C++ 的类型系统，使得泛型程序设计变得更加的强大；当然目前正在标准讨论中的 Concepts 将会让 C++ 的 template 变得更加“合理”，就像是给C++ template 中的类型参数加上了一层类型约束系统，让写 C++ 的泛型程序不会那么“飘”。
is_convertible 和 is_constructible 就是 type_traits 中的两个 meta function；光听名字感觉他们两者应该功能应该是差不多的，确实，但是本文探讨的是两者的区别，和 type interface 的主要问题；注意两 meta function 之间参数的顺序，如标题所示，当 T 能从 U 构造来时，也应当能从 U 转换成 T？真的是这样的吗？答案是否定的；反过来呢？答案也是否定的。这就是 C++ 的“神奇”之处，细节性的东西太多了！
将上面这段话转换成代码，就是
T t(u);	// OK T t = u; // ??? T t = u;	// OK T t(u);	// ???  按照常识，T t(u) 应该比 T t = u 更强，因为 t(u) 会考虑更多的可能情况，可以是直接构造，还可以是 explicit 显式构造，也可能有 conversion 操作的存在。所以按常理是 t(u) 更强。但情况并不总是如此！

    <footer>
      <a href="https://zyx-vec.github.io/myblog/post/is_constructible/">Read more</a>
    </footer>
  
</div>

        </article>
        
        <article>
          <h2><a href="https://zyx-vec.github.io/myblog/post/devirtualization/">C&#43;&#43;中的devirtualization</a></h2>
<div>
  
    我们都知道 C++ 中通过对象中的 vptr 指向 vtable 来实现多态，当然只有指针和引用才能表现出多态，否则的话会发生 slicing，调用构造或者拷贝构造函数，进而重新设置虚表指针 vptr 就不能实现多态。
但 devirtualization 是什么？解虚拟？从字面中我们也能看出，它表面上是虚函数调用，但实际进行的确是 static 的调用，也即编译器将虚函数的调用在编译期就进行了决议（resolution），消除了常规虚函数调用的动作，因为虚函数在运行时调用会经过多次的 indirection ，性能上会有影响，常规虚函数调用会多出几次内存访问，无论对于指令的条数，还是内存访问中的 Cache 局部性都会对性能造成一定的影响。较新版的编译器能够通过 C++11 中的关键词来进行指导 devirtualization ，这个关键词就是 final，因为虚函数中的 override 可以通过 final 来指定终止继续对该虚函数的 override，所以当传递过来的对象指针调用其所在 scope 中的虚函数时，碰巧该虚函数有 final 关键词的修饰，那么编译器就可以断定其一定是调用该类型指针内部的对应的那个虚函数。
我们可以测试一下代码来看一看 devirtualization 到底表现出来是什么
#include &lt;iostream&gt; class Base { public: virtual int value() { return 0; } }; class Derived : public Base { public: int value() final { return 1; }	// final is as an indicator to compiler }; int foo(Derived* d) { return d-&gt;value() + 13; } int main() { Derived d; int i = foo(&amp;d); return 0; }  利用指令 g++ test.

    <footer>
      <a href="https://zyx-vec.github.io/myblog/post/devirtualization/">Read more</a>
    </footer>
  
</div>

        </article>
        
        <article>
          <h2><a href="https://zyx-vec.github.io/myblog/post/gdb-commands/">gdb 基本命令</a></h2>
<div>
  
    GDB 是什么？   GDB 是强大的调试工具，属于 GNU tool chain 中的工具之一，功能能强大，常用语调试C和C++程序；不仅仅支持C/C++，还可用于调试Objective-C/Ada/Pascal程序；常用的功能包括设断点、查看源代码、查看变量的值、监测变量的值、查看内存中的内容和单步调试等等。GDB 功能强大，它能做的事也是纷繁复杂，感兴趣可以查看其官方提供的文档，真是洋洋洒洒近八百多页！
官方文档：gdb官方文档
但是常见功能并不是很多，掌握一些常用的命令，需要时再去查看文档即可。
 GDB 中常用的命令
 运行 gdb 调试器   $ gcc src.c -o a.out -g：其中-g必须加上，不然的话就缺少调试所需要的信息
$ gdb a.out
 查看源代码   list ：用于查看当前位置（根据上一次list到哪里来算）起始的10行代码，简写为 l
list linenum：查看指定行之后的10行源代码
list function：用于查看指定函数的源代码
 断点   break linenum：在指定的行位置处设一个断点，简写为 b
info breakpoints：查看当前所有断点的信息，其中断点的信息包含
info break n：查看标号为 n 的断点的信息
clear：删除指定 frame 中的所有断点
clear location：删除指定位置的断点
disable [range...]：消除指定范围的断点的效果
enable [range...]：使能指定范围的断点的效果
 查看变量值   print var：用于查看指定变量的内容，简写为 p var

    <footer>
      <a href="https://zyx-vec.github.io/myblog/post/gdb-commands/">Read more</a>
    </footer>
  
</div>

        </article>
        

      </section>

      <nav class="site-nav">
  <a href="https://zyx-vec.github.io/myblog/">Home</a>
  <a href="https://zyx-vec.github.io/myblog/post/">All posts</a>

  

</nav>


      <footer class="site-footer">
  <span class="owner">©2016 </span>

  
</footer>


    </div>

  
<script src="https://zyx-vec.github.io/myblog/js/highlight.pack.js"></script>
<script>hljs.initHighlightingOnLoad();</script>

  </body>
</html>
