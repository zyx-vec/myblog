<!DOCTYPE html>
<html lang="zh-CN">

  
<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="author" content="tldr">
  <meta name="generator" content="Hugo 0.18.1" />
  <title>TL;DR BLOG</title>

  <meta name="description" content="">
  <link rel="canonical" href="https://zyx-vec.github.io/myblog/">
  <link href="https://zyx-vec.github.io/myblog/index.xml" rel="alternate" type="application/rss+xml" title="TL;DR BLOG">
  <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Source+Code+Pro|Arvo:400,700">
  <link rel="stylesheet" href="https://zyx-vec.github.io/myblog/css/highlight.css">
  <link rel="stylesheet" href="https://zyx-vec.github.io/myblog/css/paperback.css">
</head>


  <body>
    <div class="container">

      <header>
  <h1>TL;DR BLOG</h1>

  

  
</header>


      <section>

        
        <article>
          <h2><a href="https://zyx-vec.github.io/myblog/post/is_singled_linked_list_cycle/">单链表环和相交问题</a></h2>
<div>
  
    题目
如何判断给定的一个单链表中是否存在环？找出环的起始位置？示例图如下，图中存在一个环，红色节点表示环的起点。
思路
利用快慢指针，一个指针1步每次，另一个指针2步每次，那么如果存在环的话，两个指针是一定会相遇的！为什么呢？
现形象比喻指针p1速度为1步/s，p2的速度为2步/s，那么经过n秒之后，两指针之间的距离为：n 步 = 2*n - n；可见两指针之间拉开的距离是随着时间“连续”增长的，所以说：如果存在环那么他俩是一定会相遇的，但如果不存在环的话p2一定会先于p1到达终点，他俩不会相遇。
但是如果存在环的话，如何求得环的起点呢？
现假设扯住链表的起点，将其精密的“裹在”环的周边；由之前的分析可知他俩一定会相遇，现假设相遇点为A，从上图中易知相遇的A点一定是和链表的起点“重合”的，为什么？因为p1和p2相遇时一定是p2比p1多跑了x圈，这里x是多少不重要（x的值和紧密环绕的那一部分的长度相关）！这就好像是跑步，你的速度是旁边某人的2倍，当你俩相遇时，你继续以2倍于他的速度行进，那么下一时刻就是你去要“追他一圈”了（因为你比他快），又因为你俩之间的距离时连续增长的，所以追他一圈就会耗掉“他”跑1圈的时间，那么你俩相遇的点一定还会是刚才的哪个点。换个说法就是p1和p2从同一个起点出发，那么每次他俩相遇的点都会是紧密环绕之后重合的哪个点！
如上图所示，两指针相遇点就在黑色的节点；当处于两值都处于相遇的黑色节点时，将p2拉回到蓝色的节点，然后两这同时以1步/s的速度行进，那么当他俩碰头时就是红色的节点，也就是环的起点。
代码
template &lt;typename T&gt; inline bool SingleLinkedList&lt;T&gt;::IsCycled() { bool ret; Node* p1, *p2; p1 = p2 = this-&gt;head; while(true) { p1 = p1-&gt;next_; // p1走一步 if(p2-&gt;next_ == NULL) { // p2更快，如果p2-&gt;next_ = NULL就表示没有环 ret = false; break; } else p2 = p2-&gt;next_-&gt;next_; // p2走两步 if(p1 == p2) { // 如果p1和p2相遇，那么表示有环 ret = true; break; } } if(ret) { // 如果有环，那么根据前面的分析，让p2回到链表头，和p1都以1步的速度前经，直到相遇 int i = 0; p2 = this-&gt;head; while(p1 !

    <footer>
      <a href="https://zyx-vec.github.io/myblog/post/is_singled_linked_list_cycle/">Read more</a>
    </footer>
  
</div>

        </article>
        
        <article>
          <h2><a href="https://zyx-vec.github.io/myblog/post/inline_asm_in_gcc/">在 C 中内嵌汇编代码</a></h2>
<div>
  
    C/C++ 代码中嵌入汇编
如果阅读过Linux源码，就可以发现其中的C中嵌入汇编指令；众所周知汇编生产力极低，但是汇编指令写出的程序的性能却是极高的，能够榨干CPU的计算能力。本文通过例子的方式给出在GCC中的C/C++（两个语言规则一样，下文直接用C来描述）代码中嵌入汇编代码块的一些基本规则。
基本模板
__asm__(&quot;inst0\n\t&quot;	/* basic instructions */ &quot;inst1\n\t&quot; :&quot;=?&quot;(),&quot;=?&quot;()...	/* outputs */ :&quot;?&quot;(),&quot;?&quot;()...	/* inputs */ :&quot;?&quot;...);	/* clobbered registers */ // 其中__asm__和asm是等价的，可以相互替换。  上面就是C源程序中嵌入汇编指令的基本模板。可见模板由5部分组成：
 基本框架 __asm__(); 在括号中填入汇编指令和其他上下文信息。 汇编指令部分，位于括号的前面部分，上述模板中inst0 inst1..就是汇编指令的代指。 由于嵌入的汇编代码块有一个上下文的环境，所以就需要接下来的三个:起始的限制（constraints）信息。  第一个 : 用于指定输出的变量由哪个寄存器来持有输出结果，&quot;&quot; 用于指定寄存器，() 中写变量名。 第二个 : 用于指定输入的变量由哪个寄存器来持有输入内容，&quot;&quot; 用于指定寄存器，() 中写变量名。 第三个 : 用于告诉编译器这个代码块中哪些内容是会被修改的，比如 :&quot;%eax&quot; 表示代码块中会修改寄存器%eax的值。   由于三个 : 不是必需的，有时能够看到例如 :::&quot;m&quot; 的内容，这就表示输出和输入都没有，但是这个代码块会修改内存中的内容（&quot;m&quot;表示内存）。
简单示例
#include &lt;stdio.h&gt; int main(int argc, char** argv) { int a = 10, b; __asm__(&quot;movl %1, %%eax\n\t&quot; &quot;movl %%eax, %0\n\t&quot; :&quot;=r&quot;(b)	/* output */ :&quot;r&quot; (a)	/* input */ :&quot;%eax&quot;	/* clobbered register */ ); printf(&quot;Result %d\n&quot;, b); return 0; }  上述 __asm__() 中代码的作用是将变量a中的值拷贝到变量b中。

    <footer>
      <a href="https://zyx-vec.github.io/myblog/post/inline_asm_in_gcc/">Read more</a>
    </footer>
  
</div>

        </article>
        
        <article>
          <h2><a href="https://zyx-vec.github.io/myblog/post/CPP_Object_Model/">探讨C&#43;&#43; 对象模型</a></h2>
<div>
  
    C++ 起源于 C，兼具底层和高级抽象的能力，能够进行底层操作，往往也称为“面向内存”编程；和 Java、Python 等语言不一样，C++ 中的“对象”的内存布局是透明的，可以被利用的（大雾，切勿依靠没有写入标准的一般经验），也即“面向内存”编程，而在 Java 中创建一个自己编写类的对象，但是对象实例中包含很多的“控制”和“辅助”信息，比如对象头等，内存效率比C++低，性能也更低。
除开 C++ 中的基本类型，掌握 C++ 中的对象模型，对于理解一些C++中的常见套路是很有帮助的，例如 C++ 中的 rule of three，运行时多态等等。
而对象模型中最重要的就是 virtual 机制，C++ 就是通过其实现运行时多态（runtime polymorphism）。“多态”按字面意思即多种表现形态，C++中就是利用相同的接口表现出不同的运行结果，故有编译时多态（compile time polymorphism）- 重载、模板 和 运行时多态（runtime compile polymorphism）。我们都知道 C++ 有强大的模板，而模板的开销主要在编译时，对应的运行时多态的开销主要体现在对象模型上，其中最重要的就是虚函数指针和虚函数表的存在，本文的目的就是探讨C++中的对象模型中的 virtual 机制。
虚函数的作用
虚函数的作用就是运行时多态，先看如下代码
class Animal { virtual void bark() = 0; }; class Dog : public Animal { void bark() { cout &lt;&lt; &quot;WangWang~\n&quot;; } }; class Cat : public Animal { void bark() { cout &lt;&lt; &quot;Meow~\n&quot;; } }; Animal *pet1 = new Dog(); Animal *pet2 = new Cat(); pet1-&gt;bark();	// WangWang~ pet2-&gt;bark();	// Meow~  由此可见，利用同样的运行时类型 Animal*，使用同样的接口（Interface），最终表现出不一样的行为状态。这就是运行时多态的目标，具体参考《C++程序设计与演化》（C++ D&amp;E）来探讨该技术的来源，和其中所经历的过程。

    <footer>
      <a href="https://zyx-vec.github.io/myblog/post/CPP_Object_Model/">Read more</a>
    </footer>
  
</div>

        </article>
        

      </section>

      <nav class="site-nav">
  <a href="https://zyx-vec.github.io/myblog/">Home</a>
  <a href="https://zyx-vec.github.io/myblog/post/">All posts</a>

  

    

</nav>


      <footer class="site-footer">
  <span class="owner">©2016 tldr</span>

  
</footer>


    </div>

  
<script src="https://zyx-vec.github.io/myblog/js/highlight.pack.js"></script>
<script>hljs.initHighlightingOnLoad();</script>

  </body>
</html>
