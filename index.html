<!DOCTYPE html>
<html lang="zh-CN">

  
<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="author" content="tldr">
  <meta name="generator" content="Hugo 0.18.1" />
  <title>TL;DR BLOG</title>

  <meta name="description" content="">
  <link rel="canonical" href="https://zyx-vec.github.io/myblog/">
  <link href="https://zyx-vec.github.io/myblog/index.xml" rel="alternate" type="application/rss+xml" title="TL;DR BLOG">
  <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Source+Code+Pro|Arvo:400,700">
  <link rel="stylesheet" href="https://zyx-vec.github.io/myblog/css/highlight.css">
  <link rel="stylesheet" href="https://zyx-vec.github.io/myblog/css/paperback.css">
</head>


  <body>
    <div class="container">

      <header>
  <h1>TL;DR BLOG</h1>

  

  
</header>


      <section>

        
        <article>
          <h2><a href="https://zyx-vec.github.io/myblog/post/CPP_Object_Model/">探讨C&#43;&#43; 对象模型</a></h2>
<div>
  
    C++ 起源于 C，兼具底层和高级抽象的能力，能够进行底层操作，往往也称为“面向内存”编程；和 Java、Python 等语言不一样，C++ 中的“对象”的内存布局是透明的，可以被利用的（大雾，切勿依靠没有写入标准的一般经验），也即“面向内存”编程，而在 Java 中创建一个自己编写类的对象，但是对象实例中包含很多的“控制”和“辅助”信息，比如对象头等，内存效率比C++低，性能也更低。
除开 C++ 中的基本类型，掌握 C++ 中的对象模型，对于理解一些C++中的常见套路是很有帮助的，例如 C++ 中的 rule of three，运行时多态等等。
而对象模型中最重要的就是 virtual 机制，C++ 就是通过其实现运行时多态（runtime polymorphism）。“多态”按字面意思即多种表现形态，C++中就是利用相同的接口表现出不同的运行结果，故有编译时多态（compile time polymorphism）- 重载、模板 和 运行时多态（runtime compile polymorphism）。我们都知道 C++ 有强大的模板，而模板的开销主要在编译时，对应的运行时多态的开销主要体现在对象模型上，其中最重要的就是虚函数指针和虚函数表的存在，本文的目的就是探讨C++中的对象模型中的 virtual 机制。
虚函数的作用
虚函数的作用就是运行时多态，先看如下代码
class Animal { virtual void bark() = 0; }; class Dog : public Animal { void bark() { cout &lt;&lt; &quot;WangWang~\n&quot;; } }; class Cat : public Animal { void bark() { cout &lt;&lt; &quot;Meow~\n&quot;; } }; Animal *pet1 = new Dog(); Animal *pet2 = new Cat(); pet1-&gt;bark();	// WangWang~ pet2-&gt;bark();	// Meow~  由此可见，利用同样的运行时类型 Animal*，使用同样的接口（Interface），最终表现出不一样的行为状态。这就是运行时多态的目标，具体参考《C++程序设计与演化》（C++ D&amp;E）来探讨该技术的来源，和其中所经历的过程。

    <footer>
      <a href="https://zyx-vec.github.io/myblog/post/CPP_Object_Model/">Read more</a>
    </footer>
  
</div>

        </article>
        
        <article>
          <h2><a href="https://zyx-vec.github.io/myblog/post/leveldb/">开源项目 leveldb 的编译测试</a></h2>
<div>
  
    step 0 : git clone leveldb source code.
step 1 : cd leveldb
step 2 : make
下一步将 include 头文件拷贝到 /usr/include/目录中。
step 3 : sudo cp -r ./include/leveldb /usr/include
​ db.h 可能不在 leveldb 目录中，找到他并拷贝到 /usr/include 中即可。
以下步骤将生成的动态链接库拷贝到 /usr/lib 目录中，创建两个软连接，最终得到 libleveldb.so
step 4 : sudo cp ./out-shared/libleveldb.so.1.18 /usr/lib
step 5 : cd /usr/lib
step 6 : sudo ln -s libleveldb.so.1.18 libleveldb.so.1
step 7 : sudo ln -s libleveldb.so.1 libleveldb.so
step 8 : sudo ldconfig

    <footer>
      <a href="https://zyx-vec.github.io/myblog/post/leveldb/">Read more</a>
    </footer>
  
</div>

        </article>
        
        <article>
          <h2><a href="https://zyx-vec.github.io/myblog/post/is_constructible/">is_convertible&lt;U, T&gt; 和 is_constructible&lt;T, U&gt;</a></h2>
<div>
  
    is_convertible和 is_constructible是否等价
C++ 11 中引入了强大的 type_traits，顾名思义，它增强了 C++ 的类型系统，使得泛型程序设计变得更加的强大；当然目前正在标准讨论中的 Concepts 将会让 C++ 的 template 变得更加“合理”，就像是给C++ template 中的类型参数加上了一层类型约束系统，让写 C++ 的泛型程序不会那么“飘”。
is_convertible 和 is_constructible 就是 type_traits 中的两个 meta function；光听名字感觉他们两者应该功能应该是差不多的，确实，但是本文探讨的是两者的区别，和 type interface 的主要问题；注意两 meta function 之间参数的顺序，如标题所示，当 T 能从 U 构造来时，也应当能从 U 转换成 T？真的是这样的吗？答案是否定的；反过来呢？答案也是否定的。这就是 C++ 的“神奇”之处，细节性的东西太多了！
将上面这段话转换成代码，就是
T t(u);	// OK T t = u; // ??? T t = u;	// OK T t(u);	// ???  按照常识，T t(u) 应该比 T t = u 更强，因为 t(u) 会考虑更多的可能情况，可以是直接构造，还可以调用 explicit 显式构造，也可能有 conversion 操作的存在。所以按常理是 t(u) 更强。但情况并不总是如此！

    <footer>
      <a href="https://zyx-vec.github.io/myblog/post/is_constructible/">Read more</a>
    </footer>
  
</div>

        </article>
        

      </section>

      <nav class="site-nav">
  <a href="https://zyx-vec.github.io/myblog/">Home</a>
  <a href="https://zyx-vec.github.io/myblog/post/">All posts</a>

  

    

</nav>


      <footer class="site-footer">
  <span class="owner">©2016 tldr</span>

  
</footer>


    </div>

  
<script src="https://zyx-vec.github.io/myblog/js/highlight.pack.js"></script>
<script>hljs.initHighlightingOnLoad();</script>

  </body>
</html>
