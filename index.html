<!DOCTYPE html>
<html lang="zh-CN">

  
<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="author" content="">
  <meta name="generator" content="Hugo 0.17" />
  <title>TL;DR BLOG</title>

  <meta name="description" content="">
  <link rel="canonical" href="https://zyx-vec.github.io/myblog/">
  <link href="https://zyx-vec.github.io/myblog/index.xml" rel="alternate" type="application/rss+xml" title="TL;DR BLOG">
  <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Source+Code+Pro|Arvo:400,700">
  <link rel="stylesheet" href="https://zyx-vec.github.io/myblog/css/highlight.css">
  <link rel="stylesheet" href="https://zyx-vec.github.io/myblog/css/paperback.css">
</head>


  <body>
    <div class="container">

      <header>
  <h1>TL;DR BLOG</h1>

  

  
</header>


      <section>

        
        <article>
          <h2><a href="https://zyx-vec.github.io/myblog/post/leveldb/">开源项目 leveldb 的编译测试</a></h2>
<div>
  
    step 0 : git clone leveldb source code.
step 1 : cd leveldb
step 2 : make
下一步将 include 头文件拷贝到 /usr/include/目录中。
step 3 : sudo cp -r ./include/leveldb /usr/include
​ db.h 可能不在 leveldb 目录中，找到他并拷贝到 /usr/include 中即可。
以下步骤将生成的动态链接库拷贝到 /usr/lib 目录中，创建两个软连接，最终得到 libleveldb.so
step 4 : sudo cp ./out-shared/libleveldb.so.1.18 /usr/lib
step 5 : cd /usr/lib
step 6 : sudo ln -s libleveldb.so.1.18 libleveldb.so.1
step 7 : sudo ln -s libleveldb.so.1 libleveldb.so
step 8 : sudo ldconfig

    <footer>
      <a href="https://zyx-vec.github.io/myblog/post/leveldb/">Read more</a>
    </footer>
  
</div>

        </article>
        
        <article>
          <h2><a href="https://zyx-vec.github.io/myblog/post/is_constructible/">is_convertible&lt;U, T&gt; 和 is_constructible&lt;T, U&gt;</a></h2>
<div>
  
    is_convertible和 is_constructible是否等价
C++ 11 中引入了强大的 type_traits，顾名思义，它增强了 C++ 的类型系统，使得泛型程序设计变得更加的强大；当然目前正在标准讨论中的 Concepts 将会让 C++ 的 template 变得更加“合理”，就像是给C++ template 中的类型参数加上了一层类型约束系统，让写 C++ 的泛型程序不会那么“飘”。
is_convertible 和 is_constructible 就是 type_traits 中的两个 meta function；光听名字感觉他们两者应该功能应该是差不多的，确实，但是本文探讨的是两者的区别，和 type interface 的主要问题；注意两 meta function 之间参数的顺序，如标题所示，当 T 能从 U 构造来时，也应当能从 U 转换成 T？真的是这样的吗？答案是否定的；反过来呢？答案也是否定的。这就是 C++ 的“神奇”之处，细节性的东西太多了！
将上面这段话转换成代码，就是
T t(u);	// OK T t = u; // ??? T t = u;	// OK T t(u);	// ???  按照常识，T t(u) 应该比 T t = u 更强，因为 t(u) 会考虑更多的可能情况，可以是直接构造，还可以调用 explicit 显式构造，也可能有 conversion 操作的存在。所以按常理是 t(u) 更强。但情况并不总是如此！

    <footer>
      <a href="https://zyx-vec.github.io/myblog/post/is_constructible/">Read more</a>
    </footer>
  
</div>

        </article>
        
        <article>
          <h2><a href="https://zyx-vec.github.io/myblog/post/devirtualization/">C&#43;&#43;中的devirtualization</a></h2>
<div>
  
    我们都知道 C++ 中通过对象中的 vptr 指向 vtable 来实现多态，当然只有指针和引用才能表现出多态，否则的话会发生 slicing，调用构造或者拷贝构造函数，进而重新设置虚表指针 vptr 就不能实现多态。
但 devirtualization 是什么？解虚拟？从字面中我们也能看出，它表面上是虚函数调用，但实际进行的确是 static 的调用，也即编译器将虚函数的调用在编译期就进行了决议（resolution），消除了常规虚函数调用的动作，因为虚函数在运行时调用会经过多次的 indirection ，性能上会有影响，常规虚函数调用会多出几次内存访问，无论对于指令的条数，还是内存访问中的 Cache 局部性都会对性能造成一定的影响。较新版的编译器能够通过 C++11 中的关键词来进行指导 devirtualization ，这个关键词就是 final，因为虚函数中的 override 可以通过 final 来指定终止继续对该虚函数的 override，所以当传递过来的对象指针调用其所在 scope 中的虚函数时，碰巧该虚函数有 final 关键词的修饰，那么编译器就可以断定其一定是调用该类型指针内部的对应的那个虚函数。
我们可以测试一下代码来看一看 devirtualization 到底表现出来是什么
#include &lt;iostream&gt; class Base { public: virtual int value() { return 0; } }; class Derived : public Base { public: int value() final { return 1; }	// final is as an indicator to compiler }; int foo(Derived* d) { return d-&gt;value() + 13; } int main() { Derived d; int i = foo(&amp;d); return 0; }  利用指令 g++ test.

    <footer>
      <a href="https://zyx-vec.github.io/myblog/post/devirtualization/">Read more</a>
    </footer>
  
</div>

        </article>
        

      </section>

      <nav class="site-nav">
  <a href="https://zyx-vec.github.io/myblog/">Home</a>
  <a href="https://zyx-vec.github.io/myblog/post/">All posts</a>

  

</nav>


      <footer class="site-footer">
  <span class="owner">©2016 </span>

  
</footer>


    </div>

  
<script src="https://zyx-vec.github.io/myblog/js/highlight.pack.js"></script>
<script>hljs.initHighlightingOnLoad();</script>

  </body>
</html>
