<!DOCTYPE html>
<html lang="zh-CN">

  
<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="author" content="">
  <meta name="generator" content="Hugo 0.17" />
  <title>TL;DR BLOG</title>

  <meta name="description" content="">
  <link rel="canonical" href="https://zyx-vec.github.io/myblog/">
  <link href="https://zyx-vec.github.io/myblog/index.xml" rel="alternate" type="application/rss+xml" title="TL;DR BLOG">
  <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Source+Code+Pro|Arvo:400,700">
  <link rel="stylesheet" href="https://zyx-vec.github.io/myblog/css/highlight.css">
  <link rel="stylesheet" href="https://zyx-vec.github.io/myblog/css/paperback.css">
</head>


  <body>
    <div class="container">

      <header>
  <h1>TL;DR BLOG</h1>

  

  
</header>


      <section>

        
        <article>
          <h2><a href="https://zyx-vec.github.io/myblog/post/devirtualization/">C&#43;&#43;中的devirtualization</a></h2>
<div>
  
    我们都知道 C++ 中通过对象中的 vptr 指向 vtable 来实现多态，当然只有指针和引用才能表现出多态，否则的话会发生 slicing，调用构造或者拷贝构造函数，进而重新设置虚表指针 vptr 就不能实现多态。
但 devirtualization 是什么？解虚拟？从字面中我们也能看出，它表面上是虚函数调用，但实际进行的确是 static 的调用，也即编译器将虚函数的调用在编译期就进行了决议（resolution），消除了常规虚函数调用的动作，因为虚函数在运行时调用会经过多次的 indirection ，性能上会有影响，常规虚函数调用会多出几次内存访问，无论对于指令的条数，还是内存访问中的 Cache 局部性都会对性能造成一定的影响。较新版的编译器能够通过 C++11 中的关键词来进行指导 devirtualization ，这个关键词就是 final，因为虚函数中的 override 可以通过 final 来指定终止继续对该虚函数的 override，所以当传递过来的对象指针调用其所在 scope 中的虚函数时，碰巧该虚函数有 final 关键词的修饰，那么编译器就可以断定其一定是调用该类型指针内部的对应的那个虚函数。
我们可以测试一下代码来看一看 devirtualization 到底表现出来是什么
#include &lt;iostream&gt; class Base { public: virtual int value() { return 0; } }; class Derived : public Base { public: int value() final { return 1; }	// final is as an indicator to compiler }; int foo(Derived* d) { return d-&gt;value() + 13; } int main() { Derived d; int i = foo(&amp;d); return 0; }  利用指令 g++ test.

    <footer>
      <a href="https://zyx-vec.github.io/myblog/post/devirtualization/">Read more</a>
    </footer>
  
</div>

        </article>
        
        <article>
          <h2><a href="https://zyx-vec.github.io/myblog/post/gdb-commands/">gdb 基本命令</a></h2>
<div>
  
    GDB 是什么？   GDB 是强大的调试工具，属于 GNU tool chain 中的工具之一，功能能强大，常用语调试C和C++程序；不仅仅支持C/C++，还可用于调试Objective-C/Ada/Pascal程序；常用的功能包括设断点、查看源代码、查看变量的值、监测变量的值、查看内存中的内容和单步调试等等。GDB 功能强大，它能做的事也是纷繁复杂，感兴趣可以查看其官方提供的文档，真是洋洋洒洒七百多页！
官方文档：[https://www.gnu.org/software/gdb/documentation/]()
但是常见功能并不是很多，掌握一些常用的命令，需要时再去查看文档即可。
 GDB 中常用的命令
 运行 gdb 调试器   $ gcc src.c -o a.out -g：其中-g必须加上，不然的话就缺少调试所需要的信息
$ gdb a.out
 查看源代码   list ：用于查看当前位置（根据上一次list到哪里来算）起始的10行代码，简写为 l
list linenum：查看指定行之后的10行源代码
list function：用于查看指定函数的源代码
 断点   break linenum：在指定的行位置处设一个断点，简写为 b
info breakpoints：查看当前所有断点的信息，其中断点的信息包含
| Num | Type | Disp | Enb | Address | What | | :&ndash;: | :&ndash;: | :&ndash;: | :&ndash;: | :&mdash;&ndash;: | :&ndash;: | | 标号 | 类型 | 显示？ | 使能？ | 地址 | 描述 |

    <footer>
      <a href="https://zyx-vec.github.io/myblog/post/gdb-commands/">Read more</a>
    </footer>
  
</div>

        </article>
        
        <article>
          <h2><a href="https://zyx-vec.github.io/myblog/post/static-assert/">断言assert的实现</a></h2>
<div>
  
    在C和C++语言中断言对于程序开发人员来说，具有很重要的作用。断言的作用就是要求 assert(e) 中的表达式 e 的值必须为真 true，否则的话程序就会 crash 掉，这就可以观察程序开发的过程中某一条件是否满足，或者用户输入的条件是否符合，当然 crash 掉运行的程序是很激进的做法，但也不失为一种拥有的方式。
本文描述两种 assert 的实现，一种为 compile time （编译时），另一种为 runtime （运行时断言）。
两种实现方式都很 hack，运用了一些编译器或者运行时的某些特性。compile time 的实现方式就是利用了语言中结构 struct 中的 bit filed 必须是大于等于 &gt;= 0 的，否则就出现编译错误；runtime 的实现利用了除零的非法操作，如果 assert(e) 中 e 为 false，那么就利用逻辑操作将 false 转换成 0，利用除零操作进行断言。
 compile time assert   C 中的实现方法，利用 struct 中的 bit filed 必须大于等于 0 的特点，其中要用 sizeof 将struct 包裹起来，类似于宏中经常用到的 do { // codes goes here } while(0)。
#include &lt;stdio.h&gt; #include &lt;stdlib.h&gt; #define static_assert(e) (sizeof(struct { int : -!

    <footer>
      <a href="https://zyx-vec.github.io/myblog/post/static-assert/">Read more</a>
    </footer>
  
</div>

        </article>
        

      </section>

      <nav class="site-nav">
  <a href="https://zyx-vec.github.io/myblog/">Home</a>
  <a href="https://zyx-vec.github.io/myblog/post/">All posts</a>

  

</nav>


      <footer class="site-footer">
  <span class="owner">©2016 </span>

  
</footer>


    </div>

  
<script src="https://zyx-vec.github.io/myblog/js/highlight.pack.js"></script>
<script>hljs.initHighlightingOnLoad();</script>

  </body>
</html>
