<!DOCTYPE html>
<html lang="zh-CN">

  
<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="author" content="">
  <meta name="generator" content="Hugo 0.17" />
  <title>is_convertible&lt;U, T&gt; 和 is_constructible&lt;T, U&gt; — TL;DR BLOG</title>

  <meta name="description" content="">
  <link rel="canonical" href="https://zyx-vec.github.io/myblog/post/is_constructible/">
  <link href="" rel="alternate" type="application/rss+xml" title="TL;DR BLOG">
  <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Source+Code+Pro|Arvo:400,700">
  <link rel="stylesheet" href="https://zyx-vec.github.io/myblog/css/highlight.css">
  <link rel="stylesheet" href="https://zyx-vec.github.io/myblog/css/paperback.css">
</head>


  <body>
    <div class="container">

      <header>
  <h1>is_convertible&lt;U, T&gt; 和 is_constructible&lt;T, U&gt;</h1>

  
  <time datetime="2016-10-15 23:02:11 &#43;0800 CST">2016/10/15</time>
  

  
</header>


      <article>
        <p><strong>is_convertible<U, T> 和 is_constructible<T, U> 是否等价</strong></p>

<p>C++ 11 中引入了强大的 type_traits，顾名思义，它增强了 C++ 的类型系统，使得泛型程序设计变得更加的强大；当让目前正在标准讨论中的 Concepts 将会让 C++ 的 template 变得更加“合理”，就像是给C++ template 中的类型参数加上了一层类型约束系统，让写 C++ 的泛型程序不会那么“飘”。</p>

<p><code>is_convertible</code> 和 <code>is_constructible</code> 就是 <code>type_traits</code> 中的两个 <code>meta function</code>；光听名字感觉他们两者应该功能是一样的；注意两 <code>meta function</code> 之间参数的顺序，如标题所示，当 T 从 U 构造来时，也应当能从 U 转换成 T？真的是这样的吗？答案是否定的，这就是 C++ 的“神奇”之处，细节性的东西太多了！</p>

<p>将上面这段话转换成代码，就是</p>

<pre><code class="language-c++">T t(u);		// OK
T t = u; 	// ???
</code></pre>

<p>可以通过代码来测试，代码如下</p>

<pre><code class="language-c++">#include &lt;iostream&gt;
#include &lt;type_traits&gt;

// is_constructible&lt;T, U&gt;::value
// is_convertible&lt;U, T&gt;::value

struct Foo {
	explicit Foo(int data) : data(data) {}
	int data;
};

int main() {

	std::cout &lt;&lt; std::is_convertible&lt;int, Foo&gt;::value &lt;&lt; std::endl;

	std::cout &lt;&lt; std::is_constructible&lt;Foo, int&gt;::value &lt;&lt; std::endl;

	return 0;
}
</code></pre>

<p>从上述代码中也可以发现端倪，其中类型 Foo 中定义的构造函数是 <code>explicit</code> 的，所以根据 C++ 中 explicit 关键词的用意，int 是不能（隐式）转换成 Foo 的，但是 int 却可以用来构造 Foo，那么最终的结果也就很明显了；用命令 <code>g++ test.cpp -std=c++11</code> 编译得到可执行程序，运行之，如下所示</p>

<pre><code class="language-c">$ ./a.out
0
1
</code></pre>

<ul>
<li>总结
<br /></li>
</ul>

<p>从上述的分析可知，<code>is_constructible</code> 和 <code>is_convertible</code> 之间是有区别的，其中关键词 <code>explicit</code> 就将这种区别表现出来了。因为 <code>is_convertible</code> 涉及到了隐式转换，但是 <code>explicit</code> 却阻止了这种隐式转化你的存在，所以就表现出了和 <code>is_constructible</code> 不同的结果。</p>

      </article>

      <nav class="site-nav">
  <a href="https://zyx-vec.github.io/myblog/">Home</a>
  <a href="https://zyx-vec.github.io/myblog/post/">All posts</a>

  

</nav>


      <footer class="site-footer">
  <span class="owner">©2016 </span>

  
</footer>


    </div>

  
<script src="https://zyx-vec.github.io/myblog/js/highlight.pack.js"></script>
<script>hljs.initHighlightingOnLoad();</script>


  </body>
</html>
