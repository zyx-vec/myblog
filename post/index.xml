<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Post-rsses on TL;DR BLOG</title>
    <link>https://zyx-vec.github.io/myblog/post/index.xml</link>
    <description>Recent content in Post-rsses on TL;DR BLOG</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-CN</language>
    <lastBuildDate>Sat, 15 Oct 2016 23:02:11 +0800</lastBuildDate>
    <atom:link href="https://zyx-vec.github.io/myblog/post/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>is_convertible&lt;U, T&gt; 和 is_constructible&lt;T, U&gt;</title>
      <link>https://zyx-vec.github.io/myblog/post/is_constructible/</link>
      <pubDate>Sat, 15 Oct 2016 23:02:11 +0800</pubDate>
      
      <guid>https://zyx-vec.github.io/myblog/post/is_constructible/</guid>
      <description>&lt;p&gt;&lt;strong&gt;is_convertible&lt;U, T&gt; 和 is_constructible&lt;T, U&gt; 是否等价&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;C++ 11 中引入了强大的 type_traits，顾名思义，它增强了 C++ 的类型系统，使得泛型程序设计变得更加的强大；当然目前正在标准讨论中的 Concepts 将会让 C++ 的 template 变得更加“合理”，就像是给C++ template 中的类型参数加上了一层类型约束系统，让写 C++ 的泛型程序不会那么“飘”。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;is_convertible&lt;/code&gt; 和 &lt;code&gt;is_constructible&lt;/code&gt; 就是 &lt;code&gt;type_traits&lt;/code&gt; 中的两个 &lt;code&gt;meta function&lt;/code&gt;；光听名字感觉他们两者应该功能应该是差不多的，确实，但是本文探讨的是两者的区别，和 &lt;code&gt;type interface&lt;/code&gt; 的主要问题；注意两 &lt;code&gt;meta function&lt;/code&gt; 之间参数的顺序，如标题所示，当 T 能从 U 构造来时，也应当能从 U 转换成 T？真的是这样的吗？答案是否定的；反过来呢？答案也是否定的。这就是 C++ 的“神奇”之处，细节性的东西太多了！&lt;/p&gt;

&lt;p&gt;将上面这段话转换成代码，就是&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;T t(u);		// OK
T t = u; 	// ???

T t = u;	// OK
T t(u);		// ???
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;按照常识，&lt;code&gt;T t(u)&lt;/code&gt; 应该比 &lt;code&gt;T t = u&lt;/code&gt; 更强，因为 t(u) 会考虑更多的可能情况，可以是直接构造，还可以是 explicit 显式构造，也可能有 conversion 操作的存在。所以按常理是 t(u) 更强。但情况并不总是如此！&lt;/p&gt;

&lt;p&gt;可以通过代码来看一下“常理”之中的情况，代码如下&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;#include &amp;lt;iostream&amp;gt;
#include &amp;lt;type_traits&amp;gt;

// is_constructible&amp;lt;T, U&amp;gt;::value
// is_convertible&amp;lt;U, T&amp;gt;::value

struct Foo {
  explicit Foo(int data) : data(data) {}
  int data;
};

int main() {
  std::cout &amp;lt;&amp;lt; std::is_convertible&amp;lt;int, Foo&amp;gt;::value &amp;lt;&amp;lt; std::endl;
  
  std::cout &amp;lt;&amp;lt; std::is_constructible&amp;lt;Foo, int&amp;gt;::value &amp;lt;&amp;lt; std::endl;
  
  return 0;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;从上述代码中也可以发现端倪，其中类型 Foo 中定义的构造函数是 &lt;code&gt;explicit&lt;/code&gt; 的，所以根据 C++ 中 explicit 关键词的用意，int 是不能（隐式）转换成 Foo 的，但是 int 却可以用来构造 Foo，那么最终的结果也就很明显了；用命令 &lt;code&gt;g++ test.cpp -std=c++11&lt;/code&gt; 编译得到可执行程序，运行之，如下所示&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;$ ./a.out
0
1
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;现考虑如下代码，这才是真正坑的地方，会出现怎样的情况呢？&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;#include &amp;lt;iostream&amp;gt;
#include &amp;lt;type_traits&amp;gt;

// is_constructible&amp;lt;T, U&amp;gt;::value
// is_convertible&amp;lt;U, T&amp;gt;::value

// T v = u; works
// T v(u);	???

struct Test {
  int data;
  Test(int data) : data(data) {}
private:
  explicit Test(double);  // explicit 是关键！
};

int main() {
  std::cout &amp;lt;&amp;lt; std::is_convertible&amp;lt;double, Test&amp;gt;::value &amp;lt;&amp;lt; std::endl;
  std::cout &amp;lt;&amp;lt; std::is_constructible&amp;lt;Test, double&amp;gt;::value &amp;lt;&amp;lt; std::endl;
  
  Test t = 1.0;  // OK
  Test t1(1.0);  // Error
  
  return 0;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;如上代码所示，将类型 Test 的一个构造函数声明成 &lt;code&gt;private&lt;/code&gt; 同时用 &lt;code&gt;explicit&lt;/code&gt; 修饰。同时应当注意，重载决议(&lt;code&gt;Overload resolution&lt;/code&gt;)是发生在访问控制权限检查(&lt;code&gt;Access checking&lt;/code&gt;)之前的！所以对于 &lt;code&gt;Test t = 1.0&lt;/code&gt;来说重载决议将首先发生从 double 到 int 的隐式转换，然后选择 &lt;code&gt;Test(int)&lt;/code&gt; 构造函数；其中因为 &lt;code&gt;Test(double)&lt;/code&gt; 是 &lt;code&gt;explicit&lt;/code&gt; 的，所以会&lt;strong&gt;被排除&lt;/strong&gt;，根本就不让 double 隐式构造发生。而 Test t1(1.0) 就不一样了，首先发生重载决议，&lt;strong&gt;选定&lt;/strong&gt; &lt;code&gt;explicit Test(double)&lt;/code&gt;，选定之后进行访问权限检查，发现是 private 的，故报错，所以构造失败。&lt;/p&gt;

&lt;p&gt;所以究其原因，是 explicit 改变了 type interface 的意义。它使重载决议发生不同的选择。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;总结
&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;从上述的分析可知，&lt;code&gt;is_constructible&lt;/code&gt; 和 &lt;code&gt;is_convertible&lt;/code&gt; 之间是有区别的，其中关键词 &lt;code&gt;explicit&lt;/code&gt; 就将这种区别表现出来了。因为 &lt;code&gt;is_convertible&lt;/code&gt; 可能涉及到隐式转换，但是 &lt;code&gt;explicit&lt;/code&gt; 却阻止了这种隐式转化你的存在，改变重载决议的选择，所以就表现出了和 &lt;code&gt;is_constructible&lt;/code&gt; 不同的结果。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>C&#43;&#43;中的devirtualization</title>
      <link>https://zyx-vec.github.io/myblog/post/devirtualization/</link>
      <pubDate>Tue, 11 Oct 2016 16:38:44 +0800</pubDate>
      
      <guid>https://zyx-vec.github.io/myblog/post/devirtualization/</guid>
      <description>&lt;p&gt;我们都知道 C++ 中通过对象中的 &lt;code&gt;vptr&lt;/code&gt; 指向 &lt;code&gt;vtable&lt;/code&gt; 来实现多态，当然只有指针和引用才能表现出多态，否则的话会发生 &lt;code&gt;slicing&lt;/code&gt;，调用构造或者拷贝构造函数，进而重新设置虚表指针 vptr 就不能实现多态。&lt;/p&gt;

&lt;p&gt;但 &lt;code&gt;devirtualization&lt;/code&gt; 是什么？解虚拟？从字面中我们也能看出，它表面上是虚函数调用，但实际进行的确是 &lt;code&gt;static&lt;/code&gt; 的调用，也即编译器将虚函数的调用在编译期就进行了决议（&lt;code&gt;resolution&lt;/code&gt;），消除了常规虚函数调用的动作，因为虚函数在运行时调用会经过多次的 &lt;code&gt;indirection&lt;/code&gt; ，性能上会有影响，常规虚函数调用会多出几次内存访问，无论对于指令的条数，还是内存访问中的 &lt;code&gt;Cache&lt;/code&gt; 局部性都会对性能造成一定的影响。较新版的编译器能够通过 C++11 中的关键词来进行指导 &lt;code&gt;devirtualization&lt;/code&gt; ，这个关键词就是 &lt;code&gt;final&lt;/code&gt;，因为虚函数中的 &lt;code&gt;override&lt;/code&gt; 可以通过 &lt;code&gt;final&lt;/code&gt; 来指定终止继续对该虚函数的 &lt;code&gt;override&lt;/code&gt;，所以当传递过来的对象指针调用其所在 &lt;code&gt;scope&lt;/code&gt; 中的虚函数时，碰巧该虚函数有 &lt;code&gt;final&lt;/code&gt; 关键词的修饰，那么编译器就可以&lt;strong&gt;&lt;em&gt;断定&lt;/em&gt;&lt;/strong&gt;其一定是调用该类型指针内部的对应的那个虚函数。&lt;/p&gt;

&lt;p&gt;我们可以测试一下代码来看一看 &lt;code&gt;devirtualization&lt;/code&gt; 到底表现出来是什么&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;#include &amp;lt;iostream&amp;gt;

class Base {
public:
  virtual int value() { return 0; }
};

class Derived : public Base {
public:
  int value() final { return 1; }	// final is as an indicator to compiler
};

int foo(Derived* d) {
  return d-&amp;gt;value() + 13;
}

int main() {
  Derived d;
  int i = foo(&amp;amp;d);
  return 0;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;利用指令 &lt;code&gt;g++ test.cpp -g -std=c++11&lt;/code&gt;来编译生成可执行程序，因为要用到 C++11 中的特性 &lt;code&gt;final&lt;/code&gt; 所以要指定编译的环境。&lt;/p&gt;

&lt;p&gt;利用反汇编工具 &lt;code&gt;objdump&lt;/code&gt; 将生成的可执行文件反汇编成汇编代码，看一看到底发生了什么，反汇编用到的指令为 &lt;code&gt;objdump -d a.out &amp;gt; devir_cpp11.asm&lt;/code&gt; 将其重定向到新文件中以便查看。&lt;/p&gt;

&lt;p&gt;利用编辑器查看反汇编得到的汇编代码，可以发现对 &lt;code&gt;d-&amp;gt;value()&lt;/code&gt; 的调用是如下的指令&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;00401410 &amp;lt;__Z3fooP7Derived&amp;gt;:
  401410:	55                   	push   %ebp
  401411:	89 e5                	mov    %esp,%ebp
  401413:	8b 4d 08             	mov    0x8(%ebp),%ecx	// 获得对象地址，作为参数
  401416:	e8 65 6d 00 00       	call   408180 &amp;lt;__ZN7Derived5valueEv&amp;gt; // d-&amp;gt;value()
  40141b:	83 c0 0d             	add    $0xd,%eax
  40141e:	5d                   	pop    %ebp
  40141f:	c3                   	ret
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;而如果没有利用 final 来给编译做指导，那么最终得到的汇编指令就会是下面这样的&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;00401410 &amp;lt;__Z3fooP7Derived&amp;gt;:
  401410:	55                   	push   %ebp
  401411:	89 e5                	mov    %esp,%ebp
  401413:	83 ec 08             	sub    $0x8,%esp
  401416:	8b 45 08             	mov    0x8(%ebp),%eax  // 获得对象的地址
  401419:	8b 00                	mov    (%eax),%eax     // 取出 vptr
  40141b:	8b 00                	mov    (%eax),%eax     // 取出 vtable 中的函数指针值
  40141d:	8b 4d 08             	mov    0x8(%ebp),%ecx  // 获得对象地址，作为参数
  401420:	ff d0                	call   *%eax           // 调用 d-&amp;gt;value()
  401422:	83 c0 0d             	add    $0xd,%eax
  401425:	c9                   	leave  
  401426:	c3                   	ret
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;对比两者，可以发现使用了 final 的虚函数的调用并没有用到虚指针 vptr 和虚表 vtable，而是直接进行调用，可见是编译器对此作出了优化；而没有使用 final 的版本就进行了 vptr 和 vtable 的操作，多了很多的操作。&lt;/p&gt;

&lt;p&gt;可见随着C++的不断演化，语言中特性的增加，编译器能做的事情也越来越多；从上述的对比中也可以推测性能也会有一定的提升。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>gdb 基本命令</title>
      <link>https://zyx-vec.github.io/myblog/post/gdb-commands/</link>
      <pubDate>Tue, 11 Oct 2016 16:33:09 +0800</pubDate>
      
      <guid>https://zyx-vec.github.io/myblog/post/gdb-commands/</guid>
      <description>&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;GDB 是什么？&lt;/strong&gt;
&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;GDB 是强大的调试工具，属于 GNU tool chain 中的工具之一，功能能强大，常用语调试C和C++程序；不仅仅支持C/C++，还可用于调试Objective-C/Ada/Pascal程序；常用的功能包括设断点、查看源代码、查看变量的值、监测变量的值、查看内存中的内容和单步调试等等。GDB 功能强大，它能做的事也是纷繁复杂，感兴趣可以查看其官方提供的文档，真是洋洋洒洒近八百多页！&lt;/p&gt;

&lt;p&gt;官方文档：&lt;a href=&#34;https://www.gnu.org/software/gdb/documentation/&#34;&gt;gdb官方文档&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;但是常见功能并不是很多，掌握一些常用的命令，需要时再去查看文档即可。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;GDB 中常用的命令&lt;/strong&gt;&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;运行 gdb 调试器
&lt;br /&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;code&gt;$ gcc src.c -o a.out -g&lt;/code&gt;：其中&lt;code&gt;-g&lt;/code&gt;必须加上，不然的话就缺少调试所需要的信息&lt;/p&gt;

&lt;p&gt;&lt;code&gt;$ gdb a.out&lt;/code&gt;&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;查看源代码
&lt;br /&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;code&gt;list&lt;/code&gt; ：用于查看当前位置（根据上一次list到哪里来算）起始的10行代码，简写为 &lt;code&gt;l&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;code&gt;list linenum&lt;/code&gt;：查看指定行之后的10行源代码&lt;/p&gt;

&lt;p&gt;&lt;code&gt;list function&lt;/code&gt;：用于查看指定函数的源代码&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;断点
&lt;br /&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;code&gt;break linenum&lt;/code&gt;：在指定的行位置处设一个断点，简写为 &lt;code&gt;b&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;code&gt;info breakpoints&lt;/code&gt;：查看当前所有断点的信息，其中断点的信息包含&lt;/p&gt;

&lt;p&gt;&lt;code&gt;info break n&lt;/code&gt;：查看标号为 n 的断点的信息&lt;/p&gt;

&lt;p&gt;&lt;code&gt;clear&lt;/code&gt;：删除指定 frame 中的所有断点&lt;/p&gt;

&lt;p&gt;&lt;code&gt;clear location&lt;/code&gt;：删除指定位置的断点&lt;/p&gt;

&lt;p&gt;&lt;code&gt;disable [range...]&lt;/code&gt;：消除指定范围的断点的效果&lt;/p&gt;

&lt;p&gt;&lt;code&gt;enable [range...]&lt;/code&gt;：使能指定范围的断点的效果&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;查看变量值
&lt;br /&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;code&gt;print var&lt;/code&gt;：用于查看指定变量的内容，简写为 &lt;code&gt;p var&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;指定格式的输出格式包括&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;查看内存中的值
&lt;br /&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;code&gt;x/nfu addr&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;code&gt;x addr&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;code&gt;x&lt;/code&gt;：x 为 &lt;code&gt;examine&lt;/code&gt; 的简写，用于查看指定内存地址中的内容，上述&lt;code&gt;nfu&lt;/code&gt;目的是控制查看的方式。&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;n, f, and u are all optional parameters that specify &lt;em&gt;how much&lt;/em&gt; memory to display and &lt;em&gt;how to format&lt;/em&gt; it; addr is an expression giving the address &lt;em&gt;where&lt;/em&gt; you want to start displaying memory.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;code&gt;n&lt;/code&gt;，表示重复的次数，如果为负值则向前查看&lt;/p&gt;

&lt;p&gt;&lt;code&gt;f&lt;/code&gt;，指定输出的格式，包括前面print指令中用到的 &lt;code&gt;x d u o t a f s&lt;/code&gt;，效果一样，还有一个 &lt;code&gt;i&lt;/code&gt; 选项，用来输出指令&lt;/p&gt;

&lt;p&gt;&lt;code&gt;u&lt;/code&gt;，用来指定查看数据的宽度，包括 &lt;code&gt;b h w g&lt;/code&gt; 四种，分别表示字节、2字节、4字节和8字节。&lt;/p&gt;

&lt;p&gt;例如：&lt;code&gt;(gdb) x/5i $pc-6&lt;/code&gt; 就会输出5条指令，&lt;code&gt;=&amp;gt;&lt;/code&gt; 会指明当前&lt;code&gt;$pc&lt;/code&gt;指向的指令&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;查看函数调用栈
&lt;br /&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;​&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;​
&lt;br /&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;strong&gt;命令测试&lt;/strong&gt;&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;strong&gt;总结&lt;/strong&gt;&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>断言assert的实现</title>
      <link>https://zyx-vec.github.io/myblog/post/static-assert/</link>
      <pubDate>Tue, 11 Oct 2016 15:25:05 +0800</pubDate>
      
      <guid>https://zyx-vec.github.io/myblog/post/static-assert/</guid>
      <description>&lt;p&gt;在C和C++语言中断言对于程序开发人员来说，具有很重要的作用。断言的作用就是要求 &lt;code&gt;assert(e)&lt;/code&gt; 中的表达式 &lt;code&gt;e&lt;/code&gt; 的值必须为真 &lt;code&gt;true&lt;/code&gt;，否则的话程序就会 &lt;code&gt;crash&lt;/code&gt; 掉，这就可以观察程序开发的过程中某一条件是否满足，或者用户输入的条件是否符合，当然 &lt;code&gt;crash&lt;/code&gt; 掉运行的程序是很激进的做法，但也不失为一种有用的方式。&lt;/p&gt;

&lt;p&gt;本文描述两种 &lt;code&gt;assert&lt;/code&gt; 的实现，一种为 &lt;code&gt;compile time&lt;/code&gt; （编译时），另一种为 &lt;code&gt;runtime&lt;/code&gt; （运行时）。&lt;/p&gt;

&lt;p&gt;两种实现方式都很 hack，运用了一些编译器或者运行时的某些特性。&lt;code&gt;compile time&lt;/code&gt; 的实现方式就是利用了 C 语言中结构 &lt;code&gt;struct&lt;/code&gt; 中的 &lt;code&gt;bit filed&lt;/code&gt; 必须是大于等于 &lt;code&gt;&amp;gt;= 0&lt;/code&gt; 的，否则就出现编译错误，而C++中就利用类型特化来实现，具体看下文；&lt;code&gt;runtime&lt;/code&gt; 的实现很常规了，如果 &lt;code&gt;assert(e)&lt;/code&gt; 中 &lt;code&gt;e&lt;/code&gt; 为 &lt;code&gt;false&lt;/code&gt;，那么调用 abort 退出程序即可，当然可以让断言的输出更加详细一些，例如输出所在文件名、行数、函数名和断言失败的表达式的名称等。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;compile time assert&lt;/strong&gt;
&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;C&lt;/strong&gt; 中的实现方法，利用 &lt;code&gt;struct&lt;/code&gt; 中的 &lt;code&gt;bit filed&lt;/code&gt; 必须大于等于 0 的特点，其中要用 sizeof 将struct 包裹起来，类似于宏中经常用到的 &lt;code&gt;do { // codes goes here } while(0)&lt;/code&gt;。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;  #include &amp;lt;stdio.h&amp;gt;
  #include &amp;lt;stdlib.h&amp;gt;
  
  #define static_assert(e) (sizeof(struct { int : -!(e); }))
  
  int main() {
    static_assert(13 &amp;gt; 7);
    static_assert(13 &amp;lt; 7); // error here, assert failed.
    
    return 0;
  }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;稍微解释一下：表达式 &lt;code&gt;e&lt;/code&gt; 如果为 &lt;code&gt;false&lt;/code&gt; 那么 &lt;code&gt;!(e)&lt;/code&gt; 就求值为 1，那么 &lt;code&gt;-!(e) == -1&lt;/code&gt;，显然 &lt;code&gt;bit field&lt;/code&gt; 不能为负&lt;code&gt;negative value&lt;/code&gt;，同时这是发生在编译时 &lt;code&gt;compile time&lt;/code&gt; 的检查，所以就实现了编译是 &lt;code&gt;static assert&lt;/code&gt;。&lt;/p&gt;

&lt;p&gt;从下面的运行结果中可以看出，&lt;code&gt;error: negative width in bit-field &#39;&amp;lt;anonymous&amp;gt;&#39;&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;  $ gcc .\assert.c
  .\assert.c: In function &#39;main&#39;:
  .\assert.c:4:41: error: negative width in bit-field &#39;&amp;lt;anonymous&amp;gt;&#39;
   #define static_assert(e) (sizeof(struct { int : -!(e); }))
                                           ^
  .\assert.c:8:2: note: in expansion of macro &#39;static_assert&#39;
    static_assert(13 &amp;lt; 7); // error here, assert failed.
    ^
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;C++&lt;/strong&gt; 中的实现，我们可以从 &lt;code&gt;template&lt;/code&gt; 模板出发，利用特化 &lt;code&gt;specialization&lt;/code&gt; 来实现对 &lt;code&gt;true&lt;/code&gt; 和 &lt;code&gt;false&lt;/code&gt; 的两种不同的处理方式；当求值为 &lt;code&gt;false&lt;/code&gt; 利用语言特性造成编译错误，当求值为 &lt;code&gt;true&lt;/code&gt; 是顺利通过编译即可。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;  #include &amp;lt;iostream&amp;gt;
  // 声明(declaration)一个结构体，但是没有(definition)
  template &amp;lt;bool&amp;gt;
  struct static_assert;
  // 利用 specialization 来进行当 e 求值为 true 时的特化，definition goes here.
  template &amp;lt;&amp;gt;
  struct static_assert&amp;lt;true&amp;gt; { };	// definiation
  
  int main() {
    static_assert&amp;lt;(13&amp;gt;7)&amp;gt;();	// 13&amp;gt;7 为 true
    static_assert&amp;lt;(13&amp;lt;7)&amp;gt;();	// assert failed here
    
    return 0;
  }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;从下面的运行结果中也可以看出当 &lt;code&gt;13&amp;lt;7&lt;/code&gt; 为 &lt;code&gt;false&lt;/code&gt; 时，显示编译错误：&lt;code&gt;incomplete type&lt;/code&gt;。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;  $ g++ .\assert.cpp
  .\assert.cpp: In function &#39;int main()&#39;:
  .\assert.cpp:14:24: error: invalid use of incomplete type &#39;struct static_assert&amp;lt;false&amp;gt;&#39;
    static_assert&amp;lt;(13&amp;lt;7)&amp;gt;();
                          ^
  .\assert.cpp:4:8: error: declaration of &#39;struct static_assert&amp;lt;false&amp;gt;&#39;
   struct static_assert;
          ^
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;runtime assert&lt;/code&gt;
&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;运行是断言相对于编译时断言来说，实现起来就容易很多，可以有很多的做法，只要判断出条件的值之后调用 abort() 即可。当然我还见过有人利用除零操作来实现，这就显得有些画蛇添足，本末倒置了，利用 UB 最终也不会得到什么好的结果！&lt;/p&gt;

&lt;p&gt;利用除零操作（略恶心）让程序 crash 掉，不同的平台可能会有不同的结果，下面就是给出的示例。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;  #include &amp;lt;stdio.h&amp;gt;
  #include &amp;lt;stdlib.h&amp;gt;
  
  #define assert(e) (1/(!!(e)))
  
  int main() {
    assert(13&amp;lt;7);	// assert failed. 不同的平台可能得到不同的结果！
    return 0;
  }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;理想状态下该段程序会 crash 掉，但是由于系统的原因，程序可能断言不成功。但这也给我们提供了一种思路。&lt;/p&gt;

&lt;p&gt;我们可以查看 GLibc 的实现，其中就是利用 abort 当断言失败是强制退出即可，但是其在断言失败之后会输出很多的相关信息，例如断言失败的所在的行、错误代码和函数名等等，这比我们之前实现的断言的功能更加完善。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;  // 定义的空操作宏
  #define __ASSERT_VOID_CAST(void)
  #define assert(expr)				\
  	  ((expr)						\
  	   ? __ASSERT_VOID_CAST (0)		\
  	   : __assert_fail (#expr, __FILE__, __LINE__, __ASSERT_FUNCTION))
  // #expr 	：表达式 expr 对应的字符串
  // __FILE__ ：断言所在文件的文件名
  // __LINE__ ：断言所在的行号
  // __ASSERT__FUNCTION ：发生断言所在函数的函数名，只有在特定环境下才有，否则即为空字符串
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;其中的关键是 __assert_fail 函数的实现！下面就来分析分析&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;  // assert.h
  /* This prints an &amp;quot;Assertion failed&amp;quot; message and aborts. */
  extern void _assert_fail(const char *__assertion,
                           const char *__file,
                           unsigned int __line,
                           const char *__function)
    __THROW __attribute__((__noreturn__));
  
  // assert.c
  void
  __assert_fail(const char *assertion, const char *file,
               unsigned int line, const char *function) {
    __assert_fail_base(_(&amp;quot;%s%s%s:%u:%s%sAssertion %s failed.\n%n&amp;quot;),
                      assertion, file, line, function);
  } // 可以看出其中关键是 __assert_fail_base 的实现。
  // 上述代码中的 _(&amp;quot;%s%s%s:%u:%s%sAssertion %s failed.\n%n&amp;quot;) 参数，其中 _(args) 是一个 
  // 宏，用来做修饰用， GLibc 用来翻译用。
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;从上面的代码框架可以看出 GLibc 中的 assert 的实现就是依靠对断言的表达式e进行求值，如果求到的值为false，就做出激进的行为 - 退出。同时也要注意到 __assert_failed 函数中的参数，上面也给出了介绍。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;  void
  __assert_fail_base (const char *fmt, const char *assertion, const char *file,
                      unsigned int line, const char *function)
  {
    char *str;
  
    int total;
    // __asprintf 函数将收集到的环境信息按照fmt指定的格式输出在堆内存中，然后让 str 指向它。
    if (__asprintf (&amp;amp;str, fmt,
                    __progname, __progname[0] ? &amp;quot;: &amp;quot; : &amp;quot;&amp;quot;,
                    file, line,
                    function ? function : &amp;quot;&amp;quot;, function ? &amp;quot;: &amp;quot; : &amp;quot;&amp;quot;,
                    assertion, &amp;amp;total) &amp;gt;= 0)
      {
        /* Print the message.  */
        (void) __fxprintf (NULL, &amp;quot;%s&amp;quot;, str);
        (void) fflush (stderr);
  
        total = (total + 1 + GLRO(dl_pagesize) - 1) &amp;amp; ~(GLRO(dl_pagesize) - 1);
        struct abort_msg_s *buf = __mmap (NULL, total, PROT_READ | PROT_WRITE,
                                          MAP_ANON | MAP_PRIVATE, -1, 0);
        if (__glibc_likely (buf != MAP_FAILED))
          {
            buf-&amp;gt;size = total;
            strcpy (buf-&amp;gt;msg, str);
  
            /* We have to free the old buffer since the application might
               catch the SIGABRT signal.  */
            struct abort_msg_s *old = atomic_exchange_acq (&amp;amp;__abort_msg, buf);
  
            if (old != NULL)
              __munmap (old, old-&amp;gt;size);
          }
  
        free (str);
      }
    else
      {
        /* At least print a minimal message.  */
        static const char errstr[] = &amp;quot;Unexpected error.\n&amp;quot;;
        __libc_write (STDERR_FILENO, errstr, sizeof (errstr) - 1);
      }
  
    abort ();	// 退出
  }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;从上面也可以看出，GLibc 中 assert 断言的实现比我们想像的更加复杂一下，其中涉及到了一些信息环境的输出，和abort之后所需要的 abort_mag_s 的写入，因为需要进行分析，所以要将为什么 abort 的信息输出到文件中。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;总结&lt;/strong&gt;
&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;这里主要探讨了编译时和运行时断言的实现，其中给出了C和C++的两种不同的实现；从中也可以看出一些很hack的做法，都是利用一些语言的特性和运行时的特性来做的。此外还可以联想到C++中哑代码的作用，都是利用一些语言编译过程中需要用到的一些语言规则来实现一些编译时的诊断作用；其中现在正在探讨的Concept就是其中之一，利用这些哑代码就可以实现一些这方面的功能。&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>