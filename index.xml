<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>TL;DR BLOG</title>
    <link>https://zyx-vec.github.io/myblog/index.xml</link>
    <description>Recent content on TL;DR BLOG</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-CN</language>
    <lastBuildDate>Thu, 16 Feb 2017 11:48:29 +0800</lastBuildDate>
    <atom:link href="https://zyx-vec.github.io/myblog/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>单链表环和相交问题</title>
      <link>https://zyx-vec.github.io/myblog/post/is_singled_linked_list_cycle/</link>
      <pubDate>Thu, 16 Feb 2017 11:48:29 +0800</pubDate>
      
      <guid>https://zyx-vec.github.io/myblog/post/is_singled_linked_list_cycle/</guid>
      <description>&lt;p&gt;&lt;strong&gt;题目&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;如何判断给定的一个单链表中是否存在环？找出环的起始位置？示例图如下，图中存在一个环，红色节点表示环的起点。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/zyx-vec/Image/master/is_cycled.png&#34; alt=&#34;图例1&#34; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;思路&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;利用快慢指针，一个指针1步每次，另一个指针2步每次，那么如果存在环的话，两个指针是一定会相遇的！为什么呢？&lt;/p&gt;

&lt;p&gt;现形象比喻指针p1速度为1步/s，p2的速度为2步/s，那么经过n秒之后，两指针之间的距离为：n 步 = 2*n - n；可见两指针之间拉开的距离是随着时间“连续”增长的，所以说：如果存在环那么他俩是一定会相遇的，但如果不存在环的话p2一定会先于p1到达终点，他俩不会相遇。&lt;/p&gt;

&lt;p&gt;但是如果存在环的话，如何求得环的起点呢？&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/zyx-vec/Image/master/is_cycled1.png&#34; alt=&#34;示例2&#34; /&gt;&lt;/p&gt;

&lt;p&gt;现假设扯住链表的起点，将其精密的“裹在”环的周边；由之前的分析可知他俩一定会相遇，现假设相遇点为A，从上图中易知相遇的A点一定是和链表的起点“重合”的，为什么？因为p1和p2相遇时一定是p2比p1多跑了x圈，这里x是多少不重要（x的值和紧密环绕的那一部分的长度相关）！这就好像是跑步，你的速度是旁边某人的2倍，当你俩相遇时，你继续以2倍于他的速度行进，那么下一时刻就是你去要“追他一圈”了（因为你比他快），又因为你俩之间的距离时连续增长的，所以追他一圈就会耗掉“他”跑1圈的时间，那么你俩相遇的点一定还会是刚才的哪个点。换个说法就是p1和p2从同一个起点出发，那么每次他俩相遇的点都会是紧密环绕之后重合的哪个点！&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/zyx-vec/Image/master/is_cycled2.png&#34; alt=&#34;示例3&#34; /&gt;&lt;/p&gt;

&lt;p&gt;如上图所示，两指针相遇点就在黑色的节点；当处于两值都处于相遇的黑色节点时，将p2拉回到蓝色的节点，然后两这同时以1步/s的速度行进，那么当他俩碰头时就是红色的节点，也就是环的起点。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;代码&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;template &amp;lt;typename T&amp;gt;
inline bool SingleLinkedList&amp;lt;T&amp;gt;::IsCycled() {
  bool ret;
  Node* p1, *p2;
  p1 = p2 = this-&amp;gt;head;
  while(true) {
    p1 = p1-&amp;gt;next_; // p1走一步
    if(p2-&amp;gt;next_ == NULL) { // p2更快，如果p2-&amp;gt;next_ = NULL就表示没有环
      ret = false;
      break;
    }
    else
      p2 = p2-&amp;gt;next_-&amp;gt;next_; // p2走两步
    if(p1 == p2) { // 如果p1和p2相遇，那么表示有环
      ret = true;
      break;
    }
  }
  if(ret) { // 如果有环，那么根据前面的分析，让p2回到链表头，和p1都以1步的速度前经，直到相遇
    int i = 0;
    p2 = this-&amp;gt;head;
    while(p1 != p2) {
      p1 = p1-&amp;gt;next_;
      p2 = p2-&amp;gt;next_;
      i++;
    }
    cout &amp;lt;&amp;lt; &amp;quot;Cycle starts at: &amp;quot; &amp;lt;&amp;lt; i &amp;lt;&amp;lt; endl; // 此时p1和p2都指向了环的起点
  }
  return ret;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;拓展&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;给定两个没有环的单链表，判断两链表是否相交，并求出交点？&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/zyx-vec/Image/master/is_cycled3.png&#34; alt=&#34;示例4&#34; /&gt;&lt;/p&gt;

&lt;p&gt;如上图所示，判断是否相交只需要从两个链表头同时出发，遍历下去，最后会同时达到同一个尾节点则表示相交。&lt;/p&gt;

&lt;p&gt;如何找出交点呢？&lt;/p&gt;

&lt;p&gt;把绿色节点的next_域指向一个链表的头形成一个环，问题就变成了前述的问题了！&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/zyx-vec/Image/master/is_cycled4.png&#34; alt=&#34;示例4&#34; /&gt;&lt;/p&gt;

&lt;p&gt;用同样的方法即可找出红色的两链表的交点。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>在 C 中内嵌汇编代码</title>
      <link>https://zyx-vec.github.io/myblog/post/inline_asm_in_gcc/</link>
      <pubDate>Tue, 14 Feb 2017 15:51:46 +0800</pubDate>
      
      <guid>https://zyx-vec.github.io/myblog/post/inline_asm_in_gcc/</guid>
      <description>&lt;p&gt;&lt;strong&gt;C/C++ 代码中嵌入汇编&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;如果阅读过Linux源码，就可以发现其中的C中嵌入汇编指令；众所周知汇编生产力极低，但是汇编指令写出的程序的性能却是极高的，能够榨干CPU的计算能力。本文通过例子的方式给出在GCC中的C/C++（两个语言规则一样，下文直接用C来描述）代码中嵌入汇编代码块的一些基本规则。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;基本模板&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;__asm__(&amp;quot;inst0\n\t&amp;quot;		/* basic instructions */
        &amp;quot;inst1\n\t&amp;quot;
        :&amp;quot;=?&amp;quot;(),&amp;quot;=?&amp;quot;()...	/* outputs */
        :&amp;quot;?&amp;quot;(),&amp;quot;?&amp;quot;()...		/* inputs */
        :&amp;quot;?&amp;quot;...);		/* clobbered registers */
// 其中__asm__和asm是等价的，可以相互替换。
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;上面就是C源程序中嵌入汇编指令的基本模板。可见模板由5部分组成：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;基本框架 &lt;code&gt;__asm__();&lt;/code&gt; 在括号中填入汇编指令和其他上下文信息。&lt;/li&gt;
&lt;li&gt;汇编指令部分，位于括号的前面部分，上述模板中&lt;code&gt;inst0 inst1..&lt;/code&gt;就是汇编指令的代指。&lt;/li&gt;
&lt;li&gt;由于嵌入的汇编代码块有一个&lt;strong&gt;上下文的环境&lt;/strong&gt;，所以就需要接下来的三个&lt;code&gt;:&lt;/code&gt;起始的限制（constraints）信息。

&lt;ol&gt;
&lt;li&gt;第一个 &lt;code&gt;:&lt;/code&gt; 用于指定输出的变量由哪个寄存器来&lt;strong&gt;持有输出结果&lt;/strong&gt;，&lt;code&gt;&amp;quot;&amp;quot;&lt;/code&gt; 用于指定寄存器，&lt;code&gt;()&lt;/code&gt; 中写变量名。&lt;/li&gt;
&lt;li&gt;第二个 &lt;code&gt;:&lt;/code&gt; 用于指定输入的变量由哪个寄存器来&lt;strong&gt;持有输入内容&lt;/strong&gt;，&lt;code&gt;&amp;quot;&amp;quot;&lt;/code&gt; 用于指定寄存器，&lt;code&gt;()&lt;/code&gt; 中写变量名。&lt;/li&gt;
&lt;li&gt;第三个 &lt;code&gt;:&lt;/code&gt; 用于告诉编译器这个代码块中&lt;strong&gt;哪些内容是会被修改的&lt;/strong&gt;，比如 &lt;code&gt;:&amp;quot;%eax&amp;quot;&lt;/code&gt; 表示代码块中会修改寄存器%eax的值。&lt;/li&gt;
&lt;/ol&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;由于三个 &lt;code&gt;:&lt;/code&gt; 不是必需的，有时能够看到例如 &lt;code&gt;:::&amp;quot;m&amp;quot;&lt;/code&gt; 的内容，这就表示输出和输入都没有，但是这个代码块会修改内存中的内容（&lt;code&gt;&amp;quot;m&amp;quot;&lt;/code&gt;表示内存）。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;简单示例&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;#include &amp;lt;stdio.h&amp;gt;
int main(int argc, char** argv) {
	int a = 10, b;
	__asm__(&amp;quot;movl %1, %%eax\n\t&amp;quot;
		&amp;quot;movl %%eax, %0\n\t&amp;quot;
		:&amp;quot;=r&amp;quot;(b)	/* output */
		:&amp;quot;r&amp;quot; (a)	/* input */
		:&amp;quot;%eax&amp;quot;		/* clobbered register */
	);
	printf(&amp;quot;Result %d\n&amp;quot;, b);
	return 0;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;上述 &lt;code&gt;__asm__()&lt;/code&gt; 中代码的作用是将变量a中的值拷贝到变量b中。&lt;/p&gt;

&lt;p&gt;由于汇编指令处于C的上下文中，为了让编译器能够区分输入输出的引用和寄存器的使用的区别，输入输出的引用由单个&lt;code&gt;%n&lt;/code&gt;表示，其中n表示&lt;code&gt;:::&lt;/code&gt;中括号内变量的编号（从0开始，例如上述中 %0 就是应用变量 b），而寄存器的使用由两个&lt;code&gt;%%reg&lt;/code&gt;表示；统一起来就是要有一个起始的&lt;code&gt;%&lt;/code&gt;，输入输出用数字标号表示，寄存器由常规的&lt;code&gt;%reg&lt;/code&gt;表示。&lt;/p&gt;

&lt;p&gt;接下来的 &lt;code&gt;:&amp;quot;=r&amp;quot;(b)&lt;/code&gt; 表示输出到b中，其中&lt;code&gt;=?&lt;/code&gt;中的&lt;code&gt;=&lt;/code&gt;号是必需的，用于区分输入。&lt;code&gt;r&lt;/code&gt;表示用通用寄存器（general register）来持有输出的结果，然后写入到变量b中。但是并不是只有&lt;code&gt;r&lt;/code&gt;可选，还有其他的字母用于表示其他的寄存器，下文会给出。&lt;/p&gt;

&lt;p&gt;第二个 &lt;code&gt;:&amp;quot;r&amp;quot;(a)&lt;/code&gt; 表示输入的内容位于变量a中，由通用寄存器持有，可见这里的只是&lt;code&gt;&amp;quot;r&amp;quot;&lt;/code&gt;，而没有等号，这就是输入与输出的不同，同样的还有除了&lt;code&gt;r&lt;/code&gt;之外的其他字母选项用于指定其他的寄存器来持有输入的变量值。&lt;/p&gt;

&lt;p&gt;最后一个 &lt;code&gt;:%eax&lt;/code&gt; 表示在这个汇编代码指令块中寄存器%eax的值是会被修改的，请不要依赖它们在汇编指令块之前所持有的内容。&lt;/p&gt;

&lt;p&gt;上述代码编译之后反汇编之后可以看到如下代码段，可以看到嵌入的汇编指令（编译时没开优化）：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;&amp;lt;main&amp;gt;:
55                   	push   %rbp
48 89 e5             	mov    %rsp,%rbp
48 83 ec 30          	sub    $0x30,%rsp
89 4d 10             	mov    %ecx,0x10(%rbp)
48 89 55 18          	mov    %rdx,0x18(%rbp)
e8 4c 00 00 00       	callq  100401140 &amp;lt;__main&amp;gt;
c7 45 fc 0a 00 00 00 	movl   $0xa,-0x4(%rbp)	# a = 10
8b 55 fc             	mov    -0x4(%rbp),%edx	# 取出 a 中的值
89 d0                	mov    %edx,%eax	# 将持有的值转入寄存器 %eax 中
89 c2                	mov    %eax,%edx	# 将持有的值转入寄存器 %ebx 中
89 55 f8             	mov    %edx,-0x8(%rbp)	# 将值写入到变量 b 中
8b 45 f8             	mov    -0x8(%rbp),%eax	# 接下来调用 printf 函数
89 c2                	mov    %eax,%edx
48 8d 0d 1f 1f 00 00 	lea    0x1f1f(%rip),%rcx        # 100403030 &amp;lt;.rdata&amp;gt;
e8 3a 00 00 00       	callq  100401150 &amp;lt;printf&amp;gt;
b8 00 00 00 00       	mov    $0x0,%eax
48 83 c4 30          	add    $0x30,%rsp
5d                   	pop    %rbp
c3                   	retq
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;从反汇编出来的汇编指令中可以看出 &lt;code&gt;movl %1 %%eax&lt;/code&gt; 而 &lt;code&gt;%1&lt;/code&gt; 已经由 &lt;code&gt;:&amp;quot;r&amp;quot;(a)&lt;/code&gt; 指定，所以面的汇编代码中出现了 &lt;code&gt;mov -0x4(%rbp),%edx 和 mov  %edx,%eax&lt;/code&gt; 两条指令，因为 &lt;code&gt;movl %1,%%eax&lt;/code&gt; 被翻译成了用 %edx 来持有a的值；同理 &lt;code&gt;movl %%eax, %0&lt;/code&gt; 翻译成了两条指令 &lt;code&gt;mov %eax, %edx 和 mov %edx, -0x8(%rbp)&lt;/code&gt;，由%edx来持有最终待输出到变量b中的值。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;常用的限制（Constraints）&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;寄存器操作数的限制&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;例如 &lt;code&gt;__asm__(&amp;quot;movl %%eax,%0\n\t&amp;quot; :&amp;quot;=r&amp;quot;(var))&lt;/code&gt; 中 &lt;code&gt;r&lt;/code&gt; 表示用通用寄存器来持有输出的值。处理&lt;code&gt;&amp;quot;=r&amp;quot;&lt;/code&gt;还有许多的寄存器操作数(operand)限制。&lt;/p&gt;

&lt;p&gt;r (general registers)&lt;/p&gt;

&lt;p&gt;a(%eax, %ax, %al) b(%ebx, %bx, %bl) c(%ecx, %cx, %cl) d(%edx, %dx, %dl)&lt;/p&gt;

&lt;p&gt;S(%esi, %si) D(%edi, %di)&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;内存操作数的限制&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;有些汇编指令可以直接用内存作为操作数，所以 &lt;code&gt;:&amp;quot;m&amp;quot;(var)&lt;/code&gt; 就用来表示内存var的引用，例如 &lt;code&gt;__asm__(&amp;quot;mov $13,%0\n\t&amp;quot; :&amp;quot;=m&amp;quot;(var))&lt;/code&gt; 就表示将变量var的值改写为13。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;匹配限制&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;有时候变量即充当输入，又是输出，为了方便就可以使用数字匹配的方式来简化代码的生成；例如 &lt;code&gt;__asm__(&amp;quot;incl %0&amp;quot; :&amp;quot;=a&amp;quot;(i):&amp;quot;0&amp;quot;(i))&lt;/code&gt; 这里的 &lt;code&gt;&amp;quot;0&amp;quot;&lt;/code&gt; 就是引用第0个操作数使用的寄存器。效果就是，首先 %eax 中持有i的值，然后将其加1，最后写入到i中，完成加1的操作。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;  c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%rbp)
  8b 45 f8             	mov    -0x8(%rbp),%eax
  ff c0                	inc    %eax
  89 45 f8             	mov    %eax,-0x8(%rbp)
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;限制描述符

&lt;ol&gt;
&lt;li&gt;如前所述&lt;code&gt;=&lt;/code&gt;用于描述限制输出。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&amp;amp;&lt;/code&gt;用于限制描述：操作数在&lt;code&gt;__asm__()&lt;/code&gt;代码块完成之前就会被修改，告知编译器进行一些处理。&lt;/li&gt;
&lt;/ol&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;例子&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;strcpy 函数的实现&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;  static inline char * strcpy_a(char * dest, const char * src) {
  	int d0, d1, d2;
  	__asm__ volatile(&amp;quot;1:\tlodsb\n\t&amp;quot;
  			&amp;quot;stosb\n\t&amp;quot;
  			&amp;quot;testb %%al, %%al\n\t&amp;quot;
  			&amp;quot;jne 1b&amp;quot;
  			:&amp;quot;=&amp;amp;S&amp;quot;(d0), &amp;quot;=&amp;amp;D&amp;quot;(d1), &amp;quot;=&amp;amp;a&amp;quot;(d2)
  			:&amp;quot;0&amp;quot;(src), &amp;quot;1&amp;quot;(dest)
  			:&amp;quot;memory&amp;quot;);
  	return dest;
  }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;首先将src保存在%esi(%rsi)中，dest保存在%edi(%rdi)中，同时利用=&amp;amp;来将最终值写入到内存单元中，&amp;amp;来表述&lt;code&gt;__asm__()&lt;/code&gt;过程中可变的概念。函数运行之后就开始拷贝，直到遇到&lt;code&gt;\0&lt;/code&gt;为止。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Linux 内核中系统调用的实现&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Linux 内核中利用宏来生成各个系统调用的函数代码，位于&lt;code&gt;unistd.h&lt;/code&gt;中，例如：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;  #define _syscall1(type,name,atype,a) \
  type name(atype a) \
  { \
  long __res; \
  __asm__ volatile (&amp;quot;int $0x80&amp;quot; \
  	: &amp;quot;=a&amp;quot; (__res) \	/* 最终结果保存到 %eax 中，然后输出到变量 __res 中 */
  	: &amp;quot;0&amp;quot; (__NR_##name),&amp;quot;b&amp;quot; ((long)(a))); \	/* %eax 中接收系统调用号，%ebx 中接受第一个参数 */
  if (__res &amp;gt;= 0) \
  	return (type) __res; \
  errno = -__res; \
  return -1; \
  }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;: &amp;quot;=a&amp;quot; (_res)&lt;/code&gt; 和 &lt;code&gt;: &amp;quot;0&amp;quot; (__NR__##name),&amp;quot;b&amp;quot;((long)(a));&lt;/code&gt; 限制了寄存器的使用，和系统调用的标准做法一致，%eax 中传递 &lt;code&gt;__NR_##name&lt;/code&gt;，%ebx 中传递第一个参数。返回值保存在了%eax中，然后输出到&lt;code&gt;__res&lt;/code&gt;中，最后根据 &lt;code&gt;__res&lt;/code&gt;的值，返回结果。&lt;/p&gt;

&lt;p&gt;其中 &lt;code&gt;__NR__##name&lt;/code&gt; 用于拼接字符串，生成例如 &lt;code&gt;__NR__exit&lt;/code&gt; 之类的宏名称，改值由内核代码定义，也位于&lt;code&gt;unistd.h&lt;/code&gt;头文件中。&lt;/p&gt;

&lt;p&gt;补充一下 &lt;code&gt;volatile&lt;/code&gt; 关键词的作用是告诉编译其不要对这个汇编代码段进行一些优化（例如移动代码等操作）；&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>探讨C&#43;&#43; 对象模型</title>
      <link>https://zyx-vec.github.io/myblog/post/CPP_Object_Model/</link>
      <pubDate>Sun, 06 Nov 2016 20:57:19 +0800</pubDate>
      
      <guid>https://zyx-vec.github.io/myblog/post/CPP_Object_Model/</guid>
      <description>&lt;p&gt;C++ 起源于 C，兼具底层和高级抽象的能力，能够进行底层操作，往往也称为“面向内存”编程；和 Java、Python 等语言不一样，C++ 中的“对象”的内存布局是透明的，可以被利用的（大雾，切勿依靠没有写入标准的一般经验），也即“面向内存”编程，而在 Java 中创建一个自己编写类的对象，但是对象实例中包含很多的“控制”和“辅助”信息，比如对象头等，内存效率比C++低，性能也更低。&lt;/p&gt;

&lt;p&gt;除开 C++ 中的基本类型，掌握 C++ 中的对象模型，对于理解一些C++中的常见套路是很有帮助的，例如 C++ 中的 rule of three，运行时多态等等。&lt;/p&gt;

&lt;p&gt;而对象模型中最重要的就是 virtual 机制，C++ 就是通过其实现运行时多态（runtime polymorphism）。“多态”按字面意思即多种表现形态，C++中就是利用相同的接口表现出不同的运行结果，故有编译时多态（compile time polymorphism）- 重载、模板 和 运行时多态（runtime compile polymorphism）。我们都知道 C++ 有强大的模板，而模板的开销主要在编译时，对应的运行时多态的开销主要体现在对象模型上，其中最重要的就是虚函数指针和虚函数表的存在，本文的目的就是探讨C++中的对象模型中的 virtual 机制。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;虚函数的作用&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;虚函数的作用就是运行时多态，先看如下代码&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;class Animal {
  virtual void bark() = 0;
};

class Dog : public Animal {
  void bark() { cout &amp;lt;&amp;lt; &amp;quot;WangWang~\n&amp;quot;; }
};

class Cat : public Animal {
  void bark() { cout &amp;lt;&amp;lt; &amp;quot;Meow~\n&amp;quot;; }
};

Animal *pet1 = new Dog();
Animal *pet2 = new Cat();
pet1-&amp;gt;bark();	// WangWang~
pet2-&amp;gt;bark();	// Meow~
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;由此可见，利用同样的运行时类型 Animal*，使用同样的接口（Interface），最终表现出不一样的行为状态。这就是运行时多态的目标，具体参考《C++程序设计与演化》（C++ D&amp;amp;E）来探讨该技术的来源，和其中所经历的过程。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;虚函数在对象中的具体存在形式&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;virtual 机制只在指针和引用上起作用，因为如果将子类对象赋值给父类对象，那么就会发生父类对象的“构造”，构造的过程中就会重新设置对象中的 virtual pointer，同时发生对象切片，将子类对象中的父类部分赋值给被构造的父类对象。&lt;/p&gt;

&lt;p&gt;声明为 virtual 的函数即为虚函数，派生类里面 override 父类对象中的 virtual 函数时可以不用 virtual 来修饰；类中有 virtual 函数（自己声明或者继承而来的）的对象中都会有至少一个虚指针 _vptr，该指针指向对应的虚表 vtable。&lt;/p&gt;

&lt;p&gt;考虑如下代码&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;#include &amp;lt;iostream&amp;gt;
#include &amp;lt;cassert&amp;gt;
using namespace std;

class Base {
public:
  Base() : a(0) {}
  virtual void fun1() {
    cout &amp;lt;&amp;lt; &amp;quot;Base::fun1&amp;quot; &amp;lt;&amp;lt; endl;
  }
  virtual void fun2() {
    cout &amp;lt;&amp;lt; &amp;quot;Base::fun2&amp;quot; &amp;lt;&amp;lt; endl;
  }
private:
  int a;
};

typedef void (*funPtr)();  // 定义类型为 void () 的函数指针类型

int main() {
  Base b;
  // 枚举 Base 的对象 b 中的内存内容
  cout &amp;lt;&amp;lt; &amp;quot;-----obj-----\n&amp;quot;;
  for(int i = 0; i &amp;lt; sizeof(b); i+=4) {
  	cout &amp;lt;&amp;lt; hex &amp;lt;&amp;lt; *((int *)(((char*)&amp;amp;b)+i)) &amp;lt;&amp;lt; endl;
  }
  // 利用vptr找到虚表，然后枚举调用虚表中函数
  cout &amp;lt;&amp;lt; &amp;quot;-----vtable-----\n&amp;quot;;
  int *fx = (int *)(*((int *)(((char*)&amp;amp;b)+0)));
  ((funPtr)(fx[0]))();  // 调用虚函数
  ((funPtr)(fx[1]))();
  
  return 0;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;用 g++ 编译运行改代码可以得到如下结果（不同的环境下可能得到不同的数值）&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;-----obj-----
40a5b8  &amp;lt;-------------- _vptr 的值，指向虚表的起始地址
0       &amp;lt;-------------- 对象中数据成员 a
-----vtable-----
Base::fun1  &amp;lt;---------- 利用虚表中的第一个指针成员成功调用 virtual void fun1 函数
Base::fun2  &amp;lt;---------- 利用虚表中的第一个指针成员成功调用 virtual void fun2 函数
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;通过该结果，结合 gdb 等调试工具，就可以刻画出virtual 机制下 的对象模型&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/zyx-vec/Image/master/%E8%99%9A%E8%A1%A8.png&#34; alt=&#34;虚表&#34; /&gt;&lt;/p&gt;

&lt;p&gt;可见 obj 对象中保存着一个 _vptr，其指向一个虚表，虚表中存放着函数的地址（指令的地址），当进行虚函数调用时，通过 _vptr 找到虚表，再通过虚表找到具体的指令地址（对应调用函数的代码区域），可见这里涉及到多次跳转；但不要忘了 C++ 中有 devirtualization 的优化机制，可以参考之前的文章：&lt;a href=&#34;https://zyx-vec.github.io/myblog/post/devirtualization/&#34;&gt;C++中的devirtualization机制&lt;/a&gt;。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;单继承&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;弄明白虚函数的具体存在形式之后，就可以探讨更深入一点的话题了；面向对象中必不可少的就是继承。C++ 中有多种继承方式，首先来探讨一下简单的单继承。&lt;/p&gt;

&lt;p&gt;测试代码&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;#include &amp;lt;iostream&amp;gt;
using namespace std;

class Base {
public:
  Base() : b(0) {}
  virtual void fun1() {
  	cout &amp;lt;&amp;lt; &amp;quot;Base::fun1&amp;quot; &amp;lt;&amp;lt; endl;
  }
  virtual void fun2() {
  	cout &amp;lt;&amp;lt; &amp;quot;Base::fun2&amp;quot; &amp;lt;&amp;lt; endl;
  }
private:
  int b;
};

class Derived : public Base { // 公有继承，表 is-a 的关系
public:
  Derived() : d(1) {}
  virtual void fun2() {     // override 基类中的 fun2 函数
  	cout &amp;lt;&amp;lt; &amp;quot;Derived::fun2&amp;quot; &amp;lt;&amp;lt; endl;
  }
  virtual void unique() {   // 派生类中独有的 virtual 函数 unique
  	cout &amp;lt;&amp;lt; &amp;quot;Derived::unique&amp;quot; &amp;lt;&amp;lt; endl;
  }
private:
  int d;
};

typedef void (*funPtr)();

int main() {
  Base b;
  
  cout &amp;lt;&amp;lt; &amp;quot;-----base::obj-----\n&amp;quot;;
  for(int i = 0; i &amp;lt; sizeof(b); i+=4) {
  	cout &amp;lt;&amp;lt; hex &amp;lt;&amp;lt; *((int *)(((char*)&amp;amp;b)+i)) &amp;lt;&amp;lt; endl;
  }
  cout &amp;lt;&amp;lt; &amp;quot;-----base::vtable-----\n&amp;quot;;
  int *fx = (int *)(*((int *)(((char*)&amp;amp;b)+0)));
  ((funPtr)(fx[0]))();
  ((funPtr)(fx[1]))();
  cout &amp;lt;&amp;lt; fx[2] &amp;lt;&amp;lt; endl;
  
  
  Derived d;
  cout &amp;lt;&amp;lt; &amp;quot;-----derived::obj-----\n&amp;quot;;
  for(int i = 0; i &amp;lt; sizeof(d); i+=4) {
  	cout &amp;lt;&amp;lt; hex &amp;lt;&amp;lt; *((int *)(((char*)&amp;amp;d)+i)) &amp;lt;&amp;lt; endl;
  }
  cout &amp;lt;&amp;lt; &amp;quot;-----derived::vtable-----\n&amp;quot;;
  int *fs = (int *)(*((int *)(((char*)&amp;amp;d)+0)));
  ((funPtr)(fs[0]))();
  ((funPtr)(fs[1]))();
  ((funPtr)(fs[2]))();
  cout &amp;lt;&amp;lt; fx[3] &amp;lt;&amp;lt; endl;
  
  return 0;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;用 g++ 编译运行的结果（不同的环境，结果可能不同）&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;-----base::obj-----
40a610      &amp;lt;--------------- Base类的对象b中的 _vptr
0           &amp;lt;--------------- Base类的对象b中的数据成员 a
-----base::vtable-----
Base::fun1  &amp;lt;--------------- 枚举Base类对应的虚表中的函数指针，进行调用
Base::fun2
0           &amp;lt;--------------- Base类的虚表中的最后一个成员值为 0
-----derived::obj-----
40a620      &amp;lt;--------------- Derived派生类的对象d中的 _vptr
0           &amp;lt;--------------- Derived派生类的对象d中继承基类中的数据成员 a
1           &amp;lt;--------------- Derived派生类的对象d中自己定义的数据成员 b
-----derived::vtable-----
Base::fun1      &amp;lt;----------- Derived类中虚表中对应的第1个虚函数
Derived::fun2   &amp;lt;----------- Derived类中虚表中对应的第2个虚函数
Derived::unique &amp;lt;----------- Derived类中虚表中对应的第3个虚函数
40a5e8          &amp;lt;----------- Derived类中虚表中的最后一个值
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;通过图形来表示就是&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/zyx-vec/Image/master/%E5%8D%95%E7%BB%A7%E6%89%BF.png&#34; alt=&#34;单继承&#34; /&gt;&lt;/p&gt;

&lt;p&gt;其中上半部分表示Base类的对象b的内存表示，下半部分表示Derived派生类的对象d的内存表示，可见派生类中 override 的基类虚函数会在派生类的虚表中被替换成 override 之后的对应的函数地址，如上图中的 Derived::&amp;amp;fun2 函数，同时可以发现单继承形式下派生类和和基类“共用”了一个虚指针。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;多重继承&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;C++ 和很多面向对象的语言不一样，它支持多继承，而像 Java 之类的就不支持多重继承；当然支持多继承既有好处也有不足，首先从实际现实情况来说，支持多继承是很自然的一件事，但多继承也会带来很多的麻烦，感兴趣的可以看一看 Ruby 之父：&lt;a href=&#34;https://www.wikiwand.com/zh-cn/%E6%9D%BE%E6%9C%AC%E8%A1%8C%E5%BC%98&#34;&gt;松本行弘&lt;/a&gt; 写的一本书 &lt;a href=&#34;https://book.douban.com/subject/6756090/&#34;&gt;松本行弘的程序世界&lt;/a&gt;，其中就给出了为什么 Ruby 中没有多继承，以及探讨了多继承的优缺点。&lt;/p&gt;

&lt;p&gt;多重继承如何处理多个基类中的虚函数？如何处理多个基类之间的虚表和派生类的虚表之间的存储的问题？&lt;/p&gt;

&lt;p&gt;示例代码&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;#include &amp;lt;iostream&amp;gt;
#include &amp;lt;cassert&amp;gt;
using namespace std;

class Base1 {
public:
  Base1() : b1(0) {}
  virtual void fun1() {
  	cout &amp;lt;&amp;lt; &amp;quot;Base1::fun1&amp;quot; &amp;lt;&amp;lt; endl;
  }
  virtual void fun2() {
  	cout &amp;lt;&amp;lt; &amp;quot;Base1::fun2&amp;quot; &amp;lt;&amp;lt; endl;
  }
private:
  int b1;
};

class Base2 {
public:
  Base2() : b2(1) {}
  virtual void fun1() {
  	cout &amp;lt;&amp;lt; &amp;quot;Base2::fun1&amp;quot; &amp;lt;&amp;lt; endl;
  }
  virtual void fun2() {
  	cout &amp;lt;&amp;lt; &amp;quot;Base2::fun2&amp;quot; &amp;lt;&amp;lt; endl;
  }
private:
  int b2;
};

class Derived : public Base1, public Base2 {
public:
  Derived() : d(2) {}
  virtual void fun2() {
  	cout &amp;lt;&amp;lt; &amp;quot;Derived::fun2&amp;quot; &amp;lt;&amp;lt; endl;
  }
  virtual void unique() {
  	cout &amp;lt;&amp;lt; &amp;quot;Derived::unique&amp;quot; &amp;lt;&amp;lt; endl;
  }
private:
  int d;
};

typedef void (*funPtr)();

int main() {
  Derived d;	
  
  cout &amp;lt;&amp;lt; &amp;quot;-----Derived::obj-----\n&amp;quot;;
  for(int i = 0; i &amp;lt; sizeof(d); i+=4) {
  	cout &amp;lt;&amp;lt; hex &amp;lt;&amp;lt; *((int *)(((char*)&amp;amp;d)+i)) &amp;lt;&amp;lt; endl;
  }
  cout &amp;lt;&amp;lt; &amp;quot;-----Derived::vtable1-----\n&amp;quot;;	// 枚举虚表
  int *fx = (int *)(*((int *)(((char*)&amp;amp;d)+0)));
  ((funPtr)(fx[0]))();
  ((funPtr)(fx[1]))();
  ((funPtr)(fx[2]))();
  cout &amp;lt;&amp;lt; &amp;quot;-----Derived::vtable2-----\n&amp;quot;;
  int *fs = (int *)(*((int *)(((char*)&amp;amp;d)+8)));
  ((funPtr)(fs[0]))();
  ((funPtr)(fs[1]))();
  
  return 0;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;g++ 下的运行结果（环境不同，结果可能不同）&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;-----Derived::obj-----
40a668      &amp;lt;--------- Base1._vptr
0           &amp;lt;--------- Base1.b1
40a67c      &amp;lt;--------- Base2._vptr
1           &amp;lt;--------- Base2.b2
2           &amp;lt;--------- Derived.d
-----Derived::vtable1-----
Base1::fun1
Derived::fun2
Derived::unique
-----Derived::vtable2-----
Base2::fun1
Derived::fun2
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;绘制成图就是&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/zyx-vec/Image/master/%E5%A4%9A%E9%87%8D%E7%BB%A7%E6%89%BF.png&#34; alt=&#34;多重继承&#34; /&gt;&lt;/p&gt;

&lt;p&gt;由此也可以总结出多重继承中 Derived::_vptr其实是和 Base::__vptr“共用”的，其中 Base1 和 Base2 中都有的 fun2 函数，由于在 Derived 被 override 覆盖了，所以会体现到两个虚表中；同时应当注意到此处只有上面的那个虚表中有 Derived::&amp;amp;unique 函数存在，当然这语义上并没有什么关系，因为无论是将 Derived 类的对象的地址赋给 Base1* 还是 Base2* 他们都不能寻址到 unique 到，因为在这两者的类型上根本就没有定义 unique 函数，所以不会有什么影响。而 fun2 就不一样了，因为 Base1* 和 Base2*（或者引用）类型上是有接口 fun2 的，所以两个虚表中的 fun2 的对应的地址都要被修改，否则的话将派生类通过基类 Base1 和 Base2 的指针和引用进行的调用将表现出不一样的东西，这当让不是我们想要的，因为我们已经在派生类中重写了虚函数 fun2。&lt;/p&gt;

&lt;p&gt;同时注意到上一个虚表中最后一个元素中存放的是值 -8，这刚好是 Base1 和 Base2 在 Derived 中对应的subtype 子对象的偏移量 8。编译器可以利用它来进行类型转换的操作（casting）。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;钻石型继承&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;存在多重继承，那么必然会出现钻石型继承（菱形继承）的情况，因为会有多条继承路径存在，有出现相交的情况。&lt;/p&gt;

&lt;p&gt;1、首先探讨存在子对象重复的情况&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/zyx-vec/Image/master/duplicatei.png&#34; alt=&#34;钻&#34; /&gt;&lt;/p&gt;

&lt;p&gt;如上图所示，其中最终的类 D 中通过两条继承路径，继承了两个相同的 Base 类，那么 D 类的对象中会存在两个 Base 子对象的实例，那么这两个部分就会出现不一致的情况，这有可能（极有可能）不是我们想要的。&lt;/p&gt;

&lt;p&gt;示例代码&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;#include &amp;lt;iostream&amp;gt;
using namespace std;

class Base {
public:
  Base() : b(0) {}
  Base(int x) : b(x) {}
  virtual void foo() {
  	cout &amp;lt;&amp;lt; &amp;quot;Base::foo &amp;quot; &amp;lt;&amp;lt; b &amp;lt;&amp;lt; endl;
  }
private:
  int b;
};

class D1 : public Base {
public:
  D1() : Base(1), d1(1) {}
  virtual void bar() {
    cout &amp;lt;&amp;lt; &amp;quot;D1::bar&amp;quot; &amp;lt;&amp;lt; endl;
  }
  virtual void buzz() {
    cout &amp;lt;&amp;lt; &amp;quot;D1::buzz&amp;quot; &amp;lt;&amp;lt; endl;
  }
private:
  int d1;
};

class D2 : public Base {
public:
  D2() : Base(2), d2(2) {}
  virtual void bar() {
  	cout &amp;lt;&amp;lt; &amp;quot;D2::bar&amp;quot; &amp;lt;&amp;lt; endl;
  }
  virtual void buzz() {
  	cout &amp;lt;&amp;lt; &amp;quot;D2::buzz&amp;quot; &amp;lt;&amp;lt; endl;
  }
private:
  int d2;
};

class Derived : public D1, public D2 {
public:
  Derived() : d(13) {}
  virtual void buzz() {
  	cout &amp;lt;&amp;lt; &amp;quot;Derived::buzz&amp;quot; &amp;lt;&amp;lt; endl;
  }
private:
  int d;
};

typedef void (*funPtr)();

int main() {
  Derived d;	
  cout &amp;lt;&amp;lt; &amp;quot;-----Derived::obj-----\n&amp;quot;;
  for(int i = 0; i &amp;lt; sizeof(d); i+=4) {
  	cout &amp;lt;&amp;lt; hex &amp;lt;&amp;lt; *((int *)(((char*)&amp;amp;d)+i)) &amp;lt;&amp;lt; endl;
  } 
  
  // 忽略 foo 中输出的 b 的值
  cout &amp;lt;&amp;lt; &amp;quot;-----Derived::vtable-----\n&amp;quot;;
  int *fx = (int *)(*((int *)(((char*)&amp;amp;d)+0)));
  ((funPtr)(fx[0]))();
  ((funPtr)(fx[1]))();
  ((funPtr)(fx[2]))();
  cout &amp;lt;&amp;lt; fx[3] &amp;lt;&amp;lt; endl;
  
  cout &amp;lt;&amp;lt; &amp;quot;-----Derived::vtable-----\n&amp;quot;;
  fx = (int *)(*((int *)(((char*)&amp;amp;d)+12)));
  ((funPtr)(fx[0]))();
  ((funPtr)(fx[1]))();
  ((funPtr)(fx[2]))();
  cout &amp;lt;&amp;lt; fx[3] &amp;lt;&amp;lt; endl;
  
  return 0;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;g++ 编译后运行结果（不同的环境，结果可能不同）：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;-----Derived::obj-----
40a668      &amp;lt;---------- D1._vptr
1           &amp;lt;---------- D1.B.b
1           &amp;lt;---------- D1.d1
40a67c      &amp;lt;---------- D2._vptr
2           &amp;lt;---------- D2.B.b
2           &amp;lt;---------- D2.d2
d           &amp;lt;---------- D.d 十六进制，十进制值为 13，可以对上
-----Derived::vtable-----
Base::foo 6     &amp;lt;--------- D1._vptr 指向的虚表中的各个函数，（忽略这里的 6 ：（
D1::bar
Derived::buzz
fffffff4        &amp;lt;--------- D1._vptr 指向的虚表中最后一个元素的值为 -12
-----Derived::vtable-----
Base::foo 6     &amp;lt;--------- D2._vptr 指向的虚表中的各个函数
D2::bar
Derived::buzz
0
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;利用 gdb 等调试工具，可以具体的查看其中的内容，最后绘制成图如下&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/zyx-vec/Image/master/duplicate.png&#34; alt=&#34;duplicate&#34; /&gt;&lt;/p&gt;

&lt;p&gt;由此也可以看出，D 类的对象中有两个虚指针，同时有*两个 Base 的子对象实例*，这里出现了重复，也就是有 D::D1::Base::b = 1 和 D::D2::Base::b = 2 两个重复的成员，这极有可能和我们的实际想法有出入。同时要注意到这里存在 D1::&amp;amp;bar 和 D2::&amp;amp;bar 的函数指针，但它并不会在 D 中与编译时造成冲突，除非发生对 bar 函数的调用，因为会出现歧义；而如果进行限定的话是可以成功调用的，即D1::bar() or D2::bar()。&lt;/p&gt;

&lt;p&gt;除此之外，在第一个虚表中的最后一个元素中存放了一个值：-12，这和 subtype 的偏移是一致的；这也和我们之前的讨论是一样的情况。&lt;/p&gt;

&lt;p&gt;2、从上面的讨论可以发现由于多重继承的存在，引入了子类型重复的现象。&lt;/p&gt;

&lt;p&gt;C++ 中引入了 virtual 继承的机制，让原本可能出现子对象重复的现象，通过子对象共享的技术使的子对象只存在一个实例。&lt;/p&gt;

&lt;p&gt;如下图所示，其中让 D 类的对象中只有一个 Base 子实例。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/zyx-vec/Image/master/virtuali.png&#34; alt=&#34;钻石&#34; /&gt;&lt;/p&gt;

&lt;p&gt;示例代码&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;#include &amp;lt;iostream&amp;gt;
using namespace std;

class Base {
public:
  Base() : b(0) {}
  Base(int x) : b(x) {}
  virtual void foo() {
  	cout &amp;lt;&amp;lt; &amp;quot;Base::foo &amp;quot; &amp;lt;&amp;lt; b &amp;lt;&amp;lt; endl;
  }
private:
  int b;
};

class D1 : virtual public Base {  // virtual 继承
public:
  D1() : Base(1), d1(1) {}
  virtual void bar() {
  	cout &amp;lt;&amp;lt; &amp;quot;D1::bar&amp;quot; &amp;lt;&amp;lt; endl;
  }
  virtual void buzz() {
  	cout &amp;lt;&amp;lt; &amp;quot;D1::buzz&amp;quot; &amp;lt;&amp;lt; endl;
  }
private:
  int d1;
};

class D2 : virtual public Base {
public:
  D2() : Base(2), d2(2) {}
  virtual void bar() {
  	cout &amp;lt;&amp;lt; &amp;quot;D2::bar&amp;quot; &amp;lt;&amp;lt; endl;
  }
  virtual void buzz() {
  	cout &amp;lt;&amp;lt; &amp;quot;D2::buzz&amp;quot; &amp;lt;&amp;lt; endl;
  }
private:
  int d2;
};

class Derived : public D1, public D2 {
public:
  Derived() : d(13) {}
  virtual void buzz() {
  	cout &amp;lt;&amp;lt; &amp;quot;Derived::buzz&amp;quot; &amp;lt;&amp;lt; endl;
  }
private:
  int d;
};

typedef void (*funPtr)();

int main() {
  Derived d;	
  cout &amp;lt;&amp;lt; &amp;quot;-----obj-----\n&amp;quot;;	
  for(int i = 0; i &amp;lt; sizeof(d); i+=4) {
  	cout &amp;lt;&amp;lt; hex &amp;lt;&amp;lt; *((int *)(((char*)&amp;amp;d)+i)) &amp;lt;&amp;lt; endl;
  }
  // 忽略 foo 中输出的 b 的值
  cout &amp;lt;&amp;lt; &amp;quot;-----vtable-----\n&amp;quot;;
  int *fx = (int *)(*((int *)(((char*)&amp;amp;d)+0)));
  ((funPtr)(fx[0]))();
  ((funPtr)(fx[1]))();
  cout &amp;lt;&amp;lt; fx[2] &amp;lt;&amp;lt; endl;
  
  cout &amp;lt;&amp;lt; &amp;quot;-----vtable-----\n&amp;quot;;
  fx = (int *)(*((int *)(((char*)&amp;amp;d)+8)));
  ((funPtr)(fx[0]))();
  ((funPtr)(fx[1]))();
  cout &amp;lt;&amp;lt; fx[2] &amp;lt;&amp;lt; endl;
  
  cout &amp;lt;&amp;lt; &amp;quot;-----vtable-----\n&amp;quot;;
  fx = (int *)(*((int *)(((char*)&amp;amp;d)+20)));
  ((funPtr)(fx[0]))();
  cout &amp;lt;&amp;lt; fx[1] &amp;lt;&amp;lt; endl;
  
  return 0;
}

/* gdb 中查看的结果
$8 = {
		&amp;lt;D1&amp;gt; = {&amp;lt;Base&amp;gt; = {_vptr.Base = 0x40a734 &amp;lt;vtable for Derived+52&amp;gt;, b = 0},
				_vptr.D1 = 0x40a70c &amp;lt;vtable for Derived+12&amp;gt;, d1 = 1},
		&amp;lt;D2&amp;gt; = {_vptr.D2 = 0x40a720 &amp;lt;vtable for Derived+32&amp;gt;, d2 = 2},
		d = 13
	 }
*/
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;g++ 中编译之后的运行结果（不同的环境，结果可能不同）&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;-----obj-----
40a70c      &amp;lt;---------- D1._vptr
1           &amp;lt;---------- D1.d1
40a720      &amp;lt;---------- D2._vptr
2           &amp;lt;---------- D2.d2
d           &amp;lt;---------- D.d 十进制值为 13，此处为十六进制 0xd
40a734      &amp;lt;---------- Base._vptr
0           &amp;lt;---------- Base.b，构造方式改变，值变成了 default value
-----vtable-----
D1::bar
Derived::buzz
c           &amp;lt;---------- 对应十进制值 12
-----vtable-----
D2::bar
Derived::buzz
0
-----vtable-----
Base::foo 6
0
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;通过调试器 gdb 和基本的测试可以绘制出下述的对象 d 的模型&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/zyx-vec/Image/master/virtual.png&#34; alt=&#34;virtual&#34; /&gt;&lt;/p&gt;

&lt;p&gt;由此可以看出，利用虚继承的机制，可以让派生类D的对象 d 中只有一个Base实例，也即上图中的绿色标注的部分。具体的 subtype 的关系见上述标注，利用偏移信息可以轻松的推导出来。注意到此时对象中的虚函数表变成了三个，因为Base子对象要单独出来形成共享，所以不能和其派生对象进行合并，所以就多出来一个。关于具体的解释，结合上图和上面的给出的代码，应该可以马上得出结果。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;总结&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;到此对一些 C++ 中基本的对象模型已经探讨完毕，实在是不容易啊，相信对 C++ 中的对象模型也有了比较清晰的认识，当然这里只针对 g++ 编译器完成，不同的编译器可能会有不同的实现方式，也即会有不同的 ABI（Application Binary Interface）；因为这些的具体实现都是在 C++ 标准中没有提及的，标准只是给出了效果，并没有规定实现方式，所以不同的厂商会有不同的发挥，比如 VC++ 就可能和 g++ 会有一定的区别，但是区别应该不大，虚指针和虚表是关键。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>开源项目 leveldb 的编译测试</title>
      <link>https://zyx-vec.github.io/myblog/post/leveldb/</link>
      <pubDate>Sat, 29 Oct 2016 14:21:52 +0800</pubDate>
      
      <guid>https://zyx-vec.github.io/myblog/post/leveldb/</guid>
      <description>&lt;p&gt;step 0 : git clone &lt;code&gt;leveldb source code&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;step 1 : cd leveldb&lt;/p&gt;

&lt;p&gt;step 2 : make&lt;/p&gt;

&lt;p&gt;下一步将 include 头文件拷贝到 /usr/include/目录中。&lt;/p&gt;

&lt;p&gt;step 3 : sudo cp -r ./include/leveldb /usr/include&lt;/p&gt;

&lt;p&gt;​   db.h 可能不在 leveldb 目录中，找到他并拷贝到 /usr/include 中即可。&lt;/p&gt;

&lt;p&gt;以下步骤将生成的动态链接库拷贝到 /usr/lib 目录中，创建两个软连接，最终得到 libleveldb.so&lt;/p&gt;

&lt;p&gt;step 4 : sudo cp ./out-shared/libleveldb.so.1.18 /usr/lib&lt;/p&gt;

&lt;p&gt;step 5 : cd /usr/lib&lt;/p&gt;

&lt;p&gt;step 6 : sudo ln -s libleveldb.so.1.18 libleveldb.so.1&lt;/p&gt;

&lt;p&gt;step 7 : sudo ln -s libleveldb.so.1 libleveldb.so&lt;/p&gt;

&lt;p&gt;step 8 : sudo ldconfig&lt;/p&gt;

&lt;p&gt;step 9 : test&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;#include &amp;lt;iostream&amp;gt;
#include &amp;lt;assert.h&amp;gt;
#include &amp;lt;string&amp;gt;
#include &amp;lt;leveldb/db.h&amp;gt;	// 从 usr/include 中寻找头文件。

int main(int argc, char* argv[]) {
  leveldb::DB* db;
  leveldb::Options options;
  options.create_is_missing = true;
  leveldb::Status status = leveldb::DB::Open(options, &amp;quot;./testdb&amp;quot;, &amp;amp;db);
  assert(status.ok());

  std::string key = &amp;quot;yellow&amp;quot;;
  std::string value = &amp;quot;banana&amp;quot;;
  std::string result;

  status = db-&amp;gt;Put(leveldb::WriteOptions(), key, value);
  if(status.ok()) {
  	status = db.Get(leveldb::ReadOptions(), &amp;quot;yellow&amp;quot;, &amp;amp;result);
    if(status.ok()) {
  	  std::cout &amp;lt;&amp;lt; result &amp;lt;&amp;lt; std::endl;
    } else {
      std::cout &amp;lt;&amp;lt; status.ToString() &amp;lt;&amp;lt; std::endl;
    }
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;step 10 : g++ test.cpp -o test -lpthread -lleveldb 用动态链接库链接之。&lt;/p&gt;

&lt;p&gt;step 11 : ./test 运行测试&lt;/p&gt;

&lt;p&gt;step 12 : g++ test.cpp -o test ./out-static/libleveldb.a -lpthread 用静态链接库链接之。&lt;/p&gt;

&lt;p&gt;step 13 : ./test 运行测试&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;// 以下是设置好 leveldb 实用环境之后的目录情况。
usr/
usr/include/
usr/include/leveldb/
usr/include/leveldb/c.h
usr/include/leveldb/cache.h
usr/include/leveldb/comparator.h
usr/include/leveldb/db.h		// db.h 可能不在 leveldb/ 目录中，拷贝到这里即可。
usr/include/leveldb/dumpfile.h
usr/include/leveldb/env.h
usr/include/leveldb/filter_policy.h
usr/include/leveldb/iterator.h
usr/include/leveldb/options.h
usr/include/leveldb/slice.h
usr/include/leveldb/status.h
usr/include/leveldb/table.h
usr/include/leveldb/table_builder.h
usr/include/leveldb/write_batch.h
usr/lib/
usr/lib/libleveldb.so
usr/lib/libleveldb.so.1
usr/lib/libleveldb.so.1.18
usr/share/
usr/share/doc/
usr/share/doc/leveldb/
usr/share/doc/leveldb/bench/
usr/share/doc/leveldb/bench/db_bench_sqlite3.cc
usr/share/doc/leveldb/bench/db_bench_tree_db.cc
usr/share/doc/leveldb/benchmark.html
usr/share/doc/leveldb/doc.css
usr/share/doc/leveldb/impl.html
usr/share/doc/leveldb/index.html
usr/share/doc/leveldb/log_format.txt
usr/share/doc/leveldb/table_format.txt
usr/share/licenses/
usr/share/licenses/leveldb/
usr/share/licenses/leveldb/LICENSE
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;lrwxrwxrwx  1 root root      15 2016-10-29 08:04 libleveldb.so -&amp;gt; libleveldb.so.1
lrwxrwxrwx  1 root root      18 2016-10-29 08:03 libleveldb.so.1 -&amp;gt; libleveldb.so.1.18
-rwxr-xr-x  1 root root  406211 2016-10-29 08:02 libleveldb.so.1.18
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>is_convertible&lt;U, T&gt; 和 is_constructible&lt;T, U&gt;</title>
      <link>https://zyx-vec.github.io/myblog/post/is_constructible/</link>
      <pubDate>Sat, 15 Oct 2016 23:02:11 +0800</pubDate>
      
      <guid>https://zyx-vec.github.io/myblog/post/is_constructible/</guid>
      <description>&lt;p&gt;&lt;strong&gt;is_convertible&lt;U, T&gt; 和 is_constructible&lt;T, U&gt; 是否等价&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;C++ 11 中引入了强大的 type_traits，顾名思义，它增强了 C++ 的类型系统，使得泛型程序设计变得更加的强大；当然目前正在标准讨论中的 Concepts 将会让 C++ 的 template 变得更加“合理”，就像是给C++ template 中的类型参数加上了一层类型约束系统，让写 C++ 的泛型程序不会那么“飘”。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;is_convertible&lt;/code&gt; 和 &lt;code&gt;is_constructible&lt;/code&gt; 就是 &lt;code&gt;type_traits&lt;/code&gt; 中的两个 &lt;code&gt;meta function&lt;/code&gt;；光听名字感觉他们两者应该功能应该是差不多的，确实，但是本文探讨的是两者的区别，和 &lt;code&gt;type interface&lt;/code&gt; 的主要问题；注意两 &lt;code&gt;meta function&lt;/code&gt; 之间参数的顺序，如标题所示，当 T 能从 U 构造来时，也应当能从 U 转换成 T？真的是这样的吗？答案是否定的；反过来呢？答案也是否定的。这就是 C++ 的“神奇”之处，细节性的东西太多了！&lt;/p&gt;

&lt;p&gt;将上面这段话转换成代码，就是&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;T t(u);		// OK
T t = u; 	// ???

T t = u;	// OK
T t(u);		// ???
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;按照常识，&lt;code&gt;T t(u)&lt;/code&gt; 应该比 &lt;code&gt;T t = u&lt;/code&gt; 更强，因为 t(u) 会考虑更多的可能情况，可以是直接构造，还可以调用 explicit 显式构造，也可能有 conversion 操作的存在。所以按常理是 t(u) 更强。但情况并不总是如此！&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;explicit 关键词的作用.&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;A constructor declared without the function-specifier explicit specifies a conversion from the types of its parameters to the type of its class. Such a constructor is called a &lt;em&gt;converting constructor&lt;/em&gt;.  （即：Foo f = 1 ==&amp;gt; Foo f(1) 发生隐式转换）。&lt;/li&gt;
&lt;li&gt;An explicit constructor constructs objects just like non-explicit constructors, &lt;em&gt;but does so only where the direct-initialization syntax (8.5) or where casts (5.2.9, 5.4) are explicitly used.&lt;/em&gt; A default constructor may be an explicit constructor; such a constructor will be used to perform default-initialization or value initialization (8.5).  不能发生1中的自动转换。&lt;/li&gt;
&lt;/ol&gt;
&lt;/blockquote&gt;

&lt;p&gt;可以通过代码来看一下“常理”之中的情况，代码如下&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;#include &amp;lt;iostream&amp;gt;
#include &amp;lt;type_traits&amp;gt;

// is_constructible&amp;lt;T, U&amp;gt;::value
// is_convertible&amp;lt;U, T&amp;gt;::value

struct Foo {
  explicit Foo(int data) : data(data) {}
  int data;
};

int main() {
  std::cout &amp;lt;&amp;lt; std::is_convertible&amp;lt;int, Foo&amp;gt;::value &amp;lt;&amp;lt; std::endl;
  std::cout &amp;lt;&amp;lt; std::is_constructible&amp;lt;Foo, int&amp;gt;::value &amp;lt;&amp;lt; std::endl;

  return 0;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;从上述代码中也可以发现端倪，其中类型 Foo 中定义的构造函数是 &lt;code&gt;explicit&lt;/code&gt; 的，所以根据 C++ 中 explicit 关键词的作用中的（1），int_val &lt;u&gt;不能&lt;/u&gt;（*隐式*）转换成 Foo(int_val) ，但是 int 却&lt;u&gt;可以&lt;/u&gt;用来&lt;em&gt;直接构造&lt;/em&gt; Foo，那么最终的结果也就很明显了；用命令 &lt;code&gt;g++ test.cpp -std=c++11&lt;/code&gt; 编译得到可执行程序，运行之，如下所示&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;$ ./a.out
0
1
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;现考虑如下代码，这才是真正坑的地方，会出现怎样的情况呢？&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;#include &amp;lt;iostream&amp;gt;
#include &amp;lt;type_traits&amp;gt;

// is_constructible&amp;lt;T, U&amp;gt;::value
// is_convertible&amp;lt;U, T&amp;gt;::value

// T v = u; works
// T v(u);	???

struct Test {
  int data;
  Test(int data) : data(data) {}
private:
  explicit Test(double);  // explicit 是关键！
};

int main() {
  std::cout &amp;lt;&amp;lt; std::is_convertible&amp;lt;double, Test&amp;gt;::value &amp;lt;&amp;lt; std::endl;
  std::cout &amp;lt;&amp;lt; std::is_constructible&amp;lt;Test, double&amp;gt;::value &amp;lt;&amp;lt; std::endl;

  Test t = 1.0;  // OK
  Test t1(1.0);  // Error

  return 0;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;如上代码所示，将类型 Test 的一个构造函数（参数为double）声明成 &lt;code&gt;private&lt;/code&gt; 同时用 &lt;code&gt;explicit&lt;/code&gt; 修饰。同时应当注意，重载决议(&lt;code&gt;Overload resolution&lt;/code&gt;)发生在访问控制权限检查(&lt;code&gt;Access checking&lt;/code&gt;)之前！所以对于 &lt;code&gt;Test t = 1.0&lt;/code&gt;来说重载决议将首先发生从 double 到 int 的隐式转换，然后选择 &lt;code&gt;Test(int)&lt;/code&gt; 构造函数；其中关键因为 &lt;code&gt;Test(double)&lt;/code&gt; 是 &lt;code&gt;explicit&lt;/code&gt; 的，根本就不让 &lt;code&gt;double&lt;/code&gt; 隐式转换构造（*Test t = 1.0 转成 Test t(1.0)*）发生，所以会&lt;strong&gt;被排除&lt;/strong&gt;掉。而 &lt;code&gt;Test t1(1.0)&lt;/code&gt; 就不一样了，首先发生重载决议，&lt;strong&gt;选定&lt;/strong&gt; &lt;code&gt;explicit Test(double)&lt;/code&gt;，选定之后进行访问权限检查，发现是 &lt;code&gt;private&lt;/code&gt; 的，故报错，所以构造失败。&lt;/p&gt;

&lt;p&gt;所以究其原因，是 explicit 改变了 type interface 的意义。它使重载决议发生不同的选择。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;总结
&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;从上述的分析可知，&lt;code&gt;is_constructible&lt;/code&gt; 和 &lt;code&gt;is_convertible&lt;/code&gt; 之间是有区别的，其中关键词 &lt;code&gt;explicit&lt;/code&gt; 就将这种区别表现出来了。因为 &lt;code&gt;is_convertible&lt;/code&gt; 可能涉及到隐式转换，但是 &lt;code&gt;explicit&lt;/code&gt; 却阻止了这种隐式转化你的存在，改变重载决议的选择，所以就表现出了和 &lt;code&gt;is_constructible&lt;/code&gt; 不同的结果。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>C&#43;&#43;中的devirtualization</title>
      <link>https://zyx-vec.github.io/myblog/post/devirtualization/</link>
      <pubDate>Tue, 11 Oct 2016 16:38:44 +0800</pubDate>
      
      <guid>https://zyx-vec.github.io/myblog/post/devirtualization/</guid>
      <description>&lt;p&gt;我们都知道 C++ 中通过对象中的 &lt;code&gt;vptr&lt;/code&gt; 指向 &lt;code&gt;vtable&lt;/code&gt; 来实现多态，当然只有指针和引用才能表现出多态，否则的话会发生 &lt;code&gt;slicing&lt;/code&gt;，调用构造或者拷贝构造函数，进而重新设置虚表指针 vptr 就不能实现多态。&lt;/p&gt;

&lt;p&gt;但 &lt;code&gt;devirtualization&lt;/code&gt; 是什么？解虚拟？从字面中我们也能看出，它表面上是虚函数调用，但实际进行的确是 &lt;code&gt;static&lt;/code&gt; 的调用，也即编译器将虚函数的调用在编译期就进行了决议（&lt;code&gt;resolution&lt;/code&gt;），消除了常规虚函数调用的动作，因为虚函数在运行时调用会经过多次的 &lt;code&gt;indirection&lt;/code&gt; ，性能上会有影响，常规虚函数调用会多出几次内存访问，无论对于指令的条数，还是内存访问中的 &lt;code&gt;Cache&lt;/code&gt; 局部性都会对性能造成一定的影响。较新版的编译器能够通过 C++11 中的关键词来进行指导 &lt;code&gt;devirtualization&lt;/code&gt; ，这个关键词就是 &lt;code&gt;final&lt;/code&gt;，因为虚函数中的 &lt;code&gt;override&lt;/code&gt; 可以通过 &lt;code&gt;final&lt;/code&gt; 来指定终止继续对该虚函数的 &lt;code&gt;override&lt;/code&gt;，所以当传递过来的对象指针调用其所在 &lt;code&gt;scope&lt;/code&gt; 中的虚函数时，碰巧该虚函数有 &lt;code&gt;final&lt;/code&gt; 关键词的修饰，那么编译器就可以&lt;strong&gt;&lt;em&gt;断定&lt;/em&gt;&lt;/strong&gt;其一定是调用该类型指针内部的对应的那个虚函数。&lt;/p&gt;

&lt;p&gt;我们可以测试一下代码来看一看 &lt;code&gt;devirtualization&lt;/code&gt; 到底表现出来是什么&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;#include &amp;lt;iostream&amp;gt;

class Base {
public:
  virtual int value() { return 0; }
};

class Derived : public Base {
public:
  int value() final { return 1; }	// final is as an indicator to compiler
};

int foo(Derived* d) {
  return d-&amp;gt;value() + 13;
}

int main() {
  Derived d;
  int i = foo(&amp;amp;d);
  return 0;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;利用指令 &lt;code&gt;g++ test.cpp -g -std=c++11&lt;/code&gt;来编译生成可执行程序，因为要用到 C++11 中的特性 &lt;code&gt;final&lt;/code&gt; 所以要指定编译的环境。&lt;/p&gt;

&lt;p&gt;利用反汇编工具 &lt;code&gt;objdump&lt;/code&gt; 将生成的可执行文件反汇编成汇编代码，看一看到底发生了什么，反汇编用到的指令为 &lt;code&gt;objdump -d a.out &amp;gt; devir_cpp11.asm&lt;/code&gt; 将其重定向到新文件中以便查看。&lt;/p&gt;

&lt;p&gt;利用编辑器查看反汇编得到的汇编代码，可以发现对 &lt;code&gt;d-&amp;gt;value()&lt;/code&gt; 的调用是如下的指令&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;00401410 &amp;lt;__Z3fooP7Derived&amp;gt;:
  401410:	55                   	push   %ebp
  401411:	89 e5                	mov    %esp,%ebp
  401413:	8b 4d 08             	mov    0x8(%ebp),%ecx	// 获得对象地址，作为参数
  401416:	e8 65 6d 00 00       	call   408180 &amp;lt;__ZN7Derived5valueEv&amp;gt; // d-&amp;gt;value()
  40141b:	83 c0 0d             	add    $0xd,%eax
  40141e:	5d                   	pop    %ebp
  40141f:	c3                   	ret
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;而如果没有利用 final 来给编译做指导，那么最终得到的汇编指令就会是下面这样的&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;00401410 &amp;lt;__Z3fooP7Derived&amp;gt;:
  401410:	55                   	push   %ebp
  401411:	89 e5                	mov    %esp,%ebp
  401413:	83 ec 08             	sub    $0x8,%esp
  401416:	8b 45 08             	mov    0x8(%ebp),%eax  // 获得对象的地址
  401419:	8b 00                	mov    (%eax),%eax     // 取出 vptr
  40141b:	8b 00                	mov    (%eax),%eax     // 取出 vtable 中的函数指针值
  40141d:	8b 4d 08             	mov    0x8(%ebp),%ecx  // 获得对象地址，作为参数
  401420:	ff d0                	call   *%eax           // 调用 d-&amp;gt;value()
  401422:	83 c0 0d             	add    $0xd,%eax
  401425:	c9                   	leave  
  401426:	c3                   	ret
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;对比两者，可以发现使用了 final 的虚函数的调用并没有用到虚指针 vptr 和虚表 vtable，而是直接进行调用，可见是编译器对此作出了优化；而没有使用 final 的版本就进行了 vptr 和 vtable 的操作，多了很多的操作。&lt;/p&gt;

&lt;p&gt;可见随着C++的不断演化，语言中特性的增加，编译器能做的事情也越来越多；从上述的对比中也可以推测性能也会有一定的提升。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>gdb 基本命令</title>
      <link>https://zyx-vec.github.io/myblog/post/gdb-commands/</link>
      <pubDate>Tue, 11 Oct 2016 16:33:09 +0800</pubDate>
      
      <guid>https://zyx-vec.github.io/myblog/post/gdb-commands/</guid>
      <description>&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;GDB 是什么？&lt;/strong&gt;
&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;GDB 是强大的调试工具，属于 GNU tool chain 中的工具之一，功能能强大，常用语调试C和C++程序；不仅仅支持C/C++，还可用于调试Objective-C/Ada/Pascal程序；常用的功能包括设断点、查看源代码、查看变量的值、监测变量的值、查看内存中的内容和单步调试等等。GDB 功能强大，它能做的事也是纷繁复杂，感兴趣可以查看其官方提供的文档，真是洋洋洒洒近八百多页！&lt;/p&gt;

&lt;p&gt;官方文档：&lt;a href=&#34;https://www.gnu.org/software/gdb/documentation/&#34;&gt;gdb官方文档&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;但是常见功能并不是很多，掌握一些常用的命令，需要时再去查看文档即可。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;GDB 中常用的命令&lt;/strong&gt;&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;运行 gdb 调试器
&lt;br /&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;code&gt;$ gcc src.c -o a.out -g&lt;/code&gt;：其中&lt;code&gt;-g&lt;/code&gt;必须加上，不然的话就缺少调试所需要的信息&lt;/p&gt;

&lt;p&gt;&lt;code&gt;$ gdb a.out&lt;/code&gt;&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;查看源代码
&lt;br /&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;code&gt;list&lt;/code&gt; ：用于查看当前位置（根据上一次list到哪里来算）起始的10行代码，简写为 &lt;code&gt;l&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;code&gt;list linenum&lt;/code&gt;：查看指定行之后的10行源代码&lt;/p&gt;

&lt;p&gt;&lt;code&gt;list function&lt;/code&gt;：用于查看指定函数的源代码&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;断点
&lt;br /&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;code&gt;break linenum&lt;/code&gt;：在指定的行位置处设一个断点，简写为 &lt;code&gt;b&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;code&gt;info breakpoints&lt;/code&gt;：查看当前所有断点的信息，其中断点的信息包含&lt;/p&gt;

&lt;p&gt;&lt;code&gt;info break n&lt;/code&gt;：查看标号为 n 的断点的信息&lt;/p&gt;

&lt;p&gt;&lt;code&gt;clear&lt;/code&gt;：删除指定 frame 中的所有断点&lt;/p&gt;

&lt;p&gt;&lt;code&gt;clear location&lt;/code&gt;：删除指定位置的断点&lt;/p&gt;

&lt;p&gt;&lt;code&gt;disable [range...]&lt;/code&gt;：消除指定范围的断点的效果&lt;/p&gt;

&lt;p&gt;&lt;code&gt;enable [range...]&lt;/code&gt;：使能指定范围的断点的效果&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;查看变量值
&lt;br /&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;code&gt;print var&lt;/code&gt;：用于查看指定变量的内容，简写为 &lt;code&gt;p var&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;指定格式的输出格式包括&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;查看内存中的值
&lt;br /&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;code&gt;x/nfu addr&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;code&gt;x addr&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;code&gt;x&lt;/code&gt;：x 为 &lt;code&gt;examine&lt;/code&gt; 的简写，用于查看指定内存地址中的内容，上述&lt;code&gt;nfu&lt;/code&gt;目的是控制查看的方式。&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;n, f, and u are all optional parameters that specify &lt;em&gt;how much&lt;/em&gt; memory to display and &lt;em&gt;how to format&lt;/em&gt; it; addr is an expression giving the address &lt;em&gt;where&lt;/em&gt; you want to start displaying memory.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;code&gt;n&lt;/code&gt;，表示重复的次数，如果为负值则向前查看&lt;/p&gt;

&lt;p&gt;&lt;code&gt;f&lt;/code&gt;，指定输出的格式，包括前面print指令中用到的 &lt;code&gt;x d u o t a f s&lt;/code&gt;，效果一样，还有一个 &lt;code&gt;i&lt;/code&gt; 选项，用来输出指令&lt;/p&gt;

&lt;p&gt;&lt;code&gt;u&lt;/code&gt;，用来指定查看数据的宽度，包括 &lt;code&gt;b h w g&lt;/code&gt; 四种，分别表示字节、2字节、4字节和8字节。&lt;/p&gt;

&lt;p&gt;例如：&lt;code&gt;(gdb) x/5i $pc-6&lt;/code&gt; 就会输出5条指令，&lt;code&gt;=&amp;gt;&lt;/code&gt; 会指明当前&lt;code&gt;$pc&lt;/code&gt;指向的指令&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;查看函数调用栈
&lt;br /&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;​&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;​
&lt;br /&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;strong&gt;命令测试&lt;/strong&gt;&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;strong&gt;总结&lt;/strong&gt;&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>断言assert的实现</title>
      <link>https://zyx-vec.github.io/myblog/post/static-assert/</link>
      <pubDate>Tue, 11 Oct 2016 15:25:05 +0800</pubDate>
      
      <guid>https://zyx-vec.github.io/myblog/post/static-assert/</guid>
      <description>&lt;p&gt;在C和C++语言中断言对于程序开发人员来说，具有很重要的作用。断言的作用就是要求 &lt;code&gt;assert(e)&lt;/code&gt; 中的表达式 &lt;code&gt;e&lt;/code&gt; 的值必须为真 &lt;code&gt;true&lt;/code&gt;，否则的话程序就会 &lt;code&gt;crash&lt;/code&gt; 掉，这就可以观察程序开发的过程中某一条件是否满足，或者用户输入的条件是否符合，当然 &lt;code&gt;crash&lt;/code&gt; 掉运行的程序是很激进的做法，但也不失为一种有用的方式。&lt;/p&gt;

&lt;p&gt;本文描述两种 &lt;code&gt;assert&lt;/code&gt; 的实现，一种为 &lt;code&gt;compile time&lt;/code&gt; （编译时），另一种为 &lt;code&gt;runtime&lt;/code&gt; （运行时）。&lt;/p&gt;

&lt;p&gt;两种实现方式都很 hack，运用了一些编译器或者运行时的某些特性。&lt;code&gt;compile time&lt;/code&gt; 的实现方式就是利用了 C 语言中结构 &lt;code&gt;struct&lt;/code&gt; 中的 &lt;code&gt;bit filed&lt;/code&gt; 必须是大于等于 &lt;code&gt;&amp;gt;= 0&lt;/code&gt; 的，否则就出现编译错误，而C++中就利用类型特化来实现，具体看下文；&lt;code&gt;runtime&lt;/code&gt; 的实现很常规了，如果 &lt;code&gt;assert(e)&lt;/code&gt; 中 &lt;code&gt;e&lt;/code&gt; 为 &lt;code&gt;false&lt;/code&gt;，那么调用 abort 退出程序即可，当然可以让断言的输出更加详细一些，例如输出所在文件名、行数、函数名和断言失败的表达式的名称等。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;compile time assert&lt;/strong&gt;
&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;C&lt;/strong&gt; 中的实现方法，利用 &lt;code&gt;struct&lt;/code&gt; 中的 &lt;code&gt;bit filed&lt;/code&gt; 必须大于等于 0 的特点，其中要用 sizeof 将struct 包裹起来，类似于宏中经常用到的 &lt;code&gt;do { // codes goes here } while(0)&lt;/code&gt;。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;  #include &amp;lt;stdio.h&amp;gt;
  #include &amp;lt;stdlib.h&amp;gt;
  
  #define static_assert(e) (sizeof(struct { int : -!(e); }))
  
  int main() {
    static_assert(13 &amp;gt; 7);
    static_assert(13 &amp;lt; 7); // error here, assert failed.
    
    return 0;
  }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;稍微解释一下：表达式 &lt;code&gt;e&lt;/code&gt; 如果为 &lt;code&gt;false&lt;/code&gt; 那么 &lt;code&gt;!(e)&lt;/code&gt; 就求值为 1，那么 &lt;code&gt;-!(e) == -1&lt;/code&gt;，显然 &lt;code&gt;bit field&lt;/code&gt; 不能为负&lt;code&gt;negative value&lt;/code&gt;，同时这是发生在编译时 &lt;code&gt;compile time&lt;/code&gt; 的检查，所以就实现了编译是 &lt;code&gt;static assert&lt;/code&gt;。&lt;/p&gt;

&lt;p&gt;从下面的运行结果中可以看出，&lt;code&gt;error: negative width in bit-field &#39;&amp;lt;anonymous&amp;gt;&#39;&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;  $ gcc .\assert.c
  .\assert.c: In function &#39;main&#39;:
  .\assert.c:4:41: error: negative width in bit-field &#39;&amp;lt;anonymous&amp;gt;&#39;
   #define static_assert(e) (sizeof(struct { int : -!(e); }))
                                           ^
  .\assert.c:8:2: note: in expansion of macro &#39;static_assert&#39;
    static_assert(13 &amp;lt; 7); // error here, assert failed.
    ^
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;C++&lt;/strong&gt; 中的实现，我们可以从 &lt;code&gt;template&lt;/code&gt; 模板出发，利用特化 &lt;code&gt;specialization&lt;/code&gt; 来实现对 &lt;code&gt;true&lt;/code&gt; 和 &lt;code&gt;false&lt;/code&gt; 的两种不同的处理方式；当求值为 &lt;code&gt;false&lt;/code&gt; 利用语言特性造成编译错误，当求值为 &lt;code&gt;true&lt;/code&gt; 是顺利通过编译即可。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;  #include &amp;lt;iostream&amp;gt;
  // 声明(declaration)一个结构体，但是没有(definition)
  template &amp;lt;bool&amp;gt;
  struct static_assert;
  // 利用 specialization 来进行当 e 求值为 true 时的特化，definition goes here.
  template &amp;lt;&amp;gt;
  struct static_assert&amp;lt;true&amp;gt; { };	// definiation
  
  int main() {
    static_assert&amp;lt;(13&amp;gt;7)&amp;gt;();	// 13&amp;gt;7 为 true
    static_assert&amp;lt;(13&amp;lt;7)&amp;gt;();	// assert failed here
    
    return 0;
  }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;从下面的运行结果中也可以看出当 &lt;code&gt;13&amp;lt;7&lt;/code&gt; 为 &lt;code&gt;false&lt;/code&gt; 时，显示编译错误：&lt;code&gt;incomplete type&lt;/code&gt;。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;  $ g++ .\assert.cpp
  .\assert.cpp: In function &#39;int main()&#39;:
  .\assert.cpp:14:24: error: invalid use of incomplete type &#39;struct static_assert&amp;lt;false&amp;gt;&#39;
    static_assert&amp;lt;(13&amp;lt;7)&amp;gt;();
                          ^
  .\assert.cpp:4:8: error: declaration of &#39;struct static_assert&amp;lt;false&amp;gt;&#39;
   struct static_assert;
          ^
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;runtime assert&lt;/code&gt;
&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;运行是断言相对于编译时断言来说，实现起来就容易很多，可以有很多的做法，只要判断出条件的值之后调用 abort() 即可。当然我还见过有人利用除零操作来实现，这就显得有些画蛇添足，本末倒置了，利用 UB 最终也不会得到什么好的结果！&lt;/p&gt;

&lt;p&gt;利用除零操作（略恶心）让程序 crash 掉，不同的平台可能会有不同的结果，下面就是给出的示例。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;  #include &amp;lt;stdio.h&amp;gt;
  #include &amp;lt;stdlib.h&amp;gt;
  
  #define assert(e) (1/(!!(e)))
  
  int main() {
    assert(13&amp;lt;7);	// assert failed. 不同的平台可能得到不同的结果！
    return 0;
  }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;理想状态下该段程序会 crash 掉，但是由于系统的原因，程序可能断言不成功。但这也给我们提供了一种思路。&lt;/p&gt;

&lt;p&gt;我们可以查看 GLibc 的实现，其中就是利用 abort 当断言失败是强制退出即可，但是其在断言失败之后会输出很多的相关信息，例如断言失败的所在的行、错误代码和函数名等等，这比我们之前实现的断言的功能更加完善。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;  // 定义的空操作宏
  #define __ASSERT_VOID_CAST(void)
  #define assert(expr)				\
  	  ((expr)						\
  	   ? __ASSERT_VOID_CAST (0)		\
  	   : __assert_fail (#expr, __FILE__, __LINE__, __ASSERT_FUNCTION))
  // #expr 	：表达式 expr 对应的字符串
  // __FILE__ ：断言所在文件的文件名
  // __LINE__ ：断言所在的行号
  // __ASSERT__FUNCTION ：发生断言所在函数的函数名，只有在特定环境下才有，否则即为空字符串
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;其中的关键是 __assert_fail 函数的实现！下面就来分析分析&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;  // assert.h
  /* This prints an &amp;quot;Assertion failed&amp;quot; message and aborts. */
  extern void _assert_fail(const char *__assertion,
                           const char *__file,
                           unsigned int __line,
                           const char *__function)
    __THROW __attribute__((__noreturn__));
  
  // assert.c
  void
  __assert_fail(const char *assertion, const char *file,
               unsigned int line, const char *function) {
    __assert_fail_base(_(&amp;quot;%s%s%s:%u:%s%sAssertion %s failed.\n%n&amp;quot;),
                      assertion, file, line, function);
  } // 可以看出其中关键是 __assert_fail_base 的实现。
  // 上述代码中的 _(&amp;quot;%s%s%s:%u:%s%sAssertion %s failed.\n%n&amp;quot;) 参数，其中 _(args) 是一个 
  // 宏，用来做修饰用， GLibc 用来翻译用。
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;从上面的代码框架可以看出 GLibc 中的 assert 的实现就是依靠对断言的表达式e进行求值，如果求到的值为false，就做出激进的行为 - 退出。同时也要注意到 __assert_failed 函数中的参数，上面也给出了介绍。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;  void
  __assert_fail_base (const char *fmt, const char *assertion, const char *file,
                      unsigned int line, const char *function)
  {
    char *str;
  
    int total;
    // __asprintf 函数将收集到的环境信息按照fmt指定的格式输出在堆内存中，然后让 str 指向它。
    if (__asprintf (&amp;amp;str, fmt,
                    __progname, __progname[0] ? &amp;quot;: &amp;quot; : &amp;quot;&amp;quot;,
                    file, line,
                    function ? function : &amp;quot;&amp;quot;, function ? &amp;quot;: &amp;quot; : &amp;quot;&amp;quot;,
                    assertion, &amp;amp;total) &amp;gt;= 0)
      {
        /* Print the message.  */
        (void) __fxprintf (NULL, &amp;quot;%s&amp;quot;, str);
        (void) fflush (stderr);
  
        total = (total + 1 + GLRO(dl_pagesize) - 1) &amp;amp; ~(GLRO(dl_pagesize) - 1);
        struct abort_msg_s *buf = __mmap (NULL, total, PROT_READ | PROT_WRITE,
                                          MAP_ANON | MAP_PRIVATE, -1, 0);
        if (__glibc_likely (buf != MAP_FAILED))
          {
            buf-&amp;gt;size = total;
            strcpy (buf-&amp;gt;msg, str);
  
            /* We have to free the old buffer since the application might
               catch the SIGABRT signal.  */
            struct abort_msg_s *old = atomic_exchange_acq (&amp;amp;__abort_msg, buf);
  
            if (old != NULL)
              __munmap (old, old-&amp;gt;size);
          }
  
        free (str);
      }
    else
      {
        /* At least print a minimal message.  */
        static const char errstr[] = &amp;quot;Unexpected error.\n&amp;quot;;
        __libc_write (STDERR_FILENO, errstr, sizeof (errstr) - 1);
      }
  
    abort ();	// 退出
  }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;从上面也可以看出，GLibc 中 assert 断言的实现比我们想像的更加复杂一下，其中涉及到了一些信息环境的输出，和abort之后所需要的 abort_mag_s 的写入，因为需要进行分析，所以要将为什么 abort 的信息输出到文件中。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;总结&lt;/strong&gt;
&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;这里主要探讨了编译时和运行时断言的实现，其中给出了C和C++的两种不同的实现；从中也可以看出一些很hack的做法，都是利用一些语言的特性和运行时的特性来做的。此外还可以联想到C++中哑代码的作用，都是利用一些语言编译过程中需要用到的一些语言规则来实现一些编译时的诊断作用；其中现在正在探讨的Concept就是其中之一，利用这些哑代码就可以实现一些这方面的功能。&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>